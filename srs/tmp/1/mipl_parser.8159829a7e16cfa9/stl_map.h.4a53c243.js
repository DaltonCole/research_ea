var data = {lines:[
{"lineNum":"    1","line":"// Map implementation -*- C++ -*-"},
{"lineNum":"    2","line":""},
{"lineNum":"    3","line":"// Copyright (C) 2001-2017 Free Software Foundation, Inc."},
{"lineNum":"    4","line":"//"},
{"lineNum":"    5","line":"// This file is part of the GNU ISO C++ Library.  This library is free"},
{"lineNum":"    6","line":"// software; you can redistribute it and/or modify it under the"},
{"lineNum":"    7","line":"// terms of the GNU General Public License as published by the"},
{"lineNum":"    8","line":"// Free Software Foundation; either version 3, or (at your option)"},
{"lineNum":"    9","line":"// any later version."},
{"lineNum":"   10","line":""},
{"lineNum":"   11","line":"// This library is distributed in the hope that it will be useful,"},
{"lineNum":"   12","line":"// but WITHOUT ANY WARRANTY; without even the implied warranty of"},
{"lineNum":"   13","line":"// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the"},
{"lineNum":"   14","line":"// GNU General Public License for more details."},
{"lineNum":"   15","line":""},
{"lineNum":"   16","line":"// Under Section 7 of GPL version 3, you are granted additional"},
{"lineNum":"   17","line":"// permissions described in the GCC Runtime Library Exception, version"},
{"lineNum":"   18","line":"// 3.1, as published by the Free Software Foundation."},
{"lineNum":"   19","line":""},
{"lineNum":"   20","line":"// You should have received a copy of the GNU General Public License and"},
{"lineNum":"   21","line":"// a copy of the GCC Runtime Library Exception along with this program;"},
{"lineNum":"   22","line":"// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see"},
{"lineNum":"   23","line":"// <http://www.gnu.org/licenses/>."},
{"lineNum":"   24","line":""},
{"lineNum":"   25","line":"/*"},
{"lineNum":"   26","line":" *"},
{"lineNum":"   27","line":" * Copyright (c) 1994"},
{"lineNum":"   28","line":" * Hewlett-Packard Company"},
{"lineNum":"   29","line":" *"},
{"lineNum":"   30","line":" * Permission to use, copy, modify, distribute and sell this software"},
{"lineNum":"   31","line":" * and its documentation for any purpose is hereby granted without fee,"},
{"lineNum":"   32","line":" * provided that the above copyright notice appear in all copies and"},
{"lineNum":"   33","line":" * that both that copyright notice and this permission notice appear"},
{"lineNum":"   34","line":" * in supporting documentation.  Hewlett-Packard Company makes no"},
{"lineNum":"   35","line":" * representations about the suitability of this software for any"},
{"lineNum":"   36","line":" * purpose.  It is provided \"as is\" without express or implied warranty."},
{"lineNum":"   37","line":" *"},
{"lineNum":"   38","line":" *"},
{"lineNum":"   39","line":" * Copyright (c) 1996,1997"},
{"lineNum":"   40","line":" * Silicon Graphics Computer Systems, Inc."},
{"lineNum":"   41","line":" *"},
{"lineNum":"   42","line":" * Permission to use, copy, modify, distribute and sell this software"},
{"lineNum":"   43","line":" * and its documentation for any purpose is hereby granted without fee,"},
{"lineNum":"   44","line":" * provided that the above copyright notice appear in all copies and"},
{"lineNum":"   45","line":" * that both that copyright notice and this permission notice appear"},
{"lineNum":"   46","line":" * in supporting documentation.  Silicon Graphics makes no"},
{"lineNum":"   47","line":" * representations about the suitability of this software for any"},
{"lineNum":"   48","line":" * purpose.  It is provided \"as is\" without express or implied warranty."},
{"lineNum":"   49","line":" */"},
{"lineNum":"   50","line":""},
{"lineNum":"   51","line":"/** @file bits/stl_map.h"},
{"lineNum":"   52","line":" *  This is an internal header file, included by other library headers."},
{"lineNum":"   53","line":" *  Do not attempt to use it directly. @headername{map}"},
{"lineNum":"   54","line":" */"},
{"lineNum":"   55","line":""},
{"lineNum":"   56","line":"#ifndef _STL_MAP_H"},
{"lineNum":"   57","line":"#define _STL_MAP_H 1"},
{"lineNum":"   58","line":""},
{"lineNum":"   59","line":"#include <bits/functexcept.h>"},
{"lineNum":"   60","line":"#include <bits/concept_check.h>"},
{"lineNum":"   61","line":"#if __cplusplus >= 201103L"},
{"lineNum":"   62","line":"#include <initializer_list>"},
{"lineNum":"   63","line":"#include <tuple>"},
{"lineNum":"   64","line":"#endif"},
{"lineNum":"   65","line":""},
{"lineNum":"   66","line":"namespace std _GLIBCXX_VISIBILITY(default)"},
{"lineNum":"   67","line":"{"},
{"lineNum":"   68","line":"_GLIBCXX_BEGIN_NAMESPACE_CONTAINER"},
{"lineNum":"   69","line":""},
{"lineNum":"   70","line":"  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>"},
{"lineNum":"   71","line":"    class multimap;"},
{"lineNum":"   72","line":""},
{"lineNum":"   73","line":"  /**"},
{"lineNum":"   74","line":"   *  @brief A standard container made up of (key,value) pairs, which can be"},
{"lineNum":"   75","line":"   *  retrieved based on a key, in logarithmic time."},
{"lineNum":"   76","line":"   *"},
{"lineNum":"   77","line":"   *  @ingroup associative_containers"},
{"lineNum":"   78","line":"   *"},
{"lineNum":"   79","line":"   *  @tparam _Key  Type of key objects."},
{"lineNum":"   80","line":"   *  @tparam  _Tp  Type of mapped objects."},
{"lineNum":"   81","line":"   *  @tparam _Compare  Comparison function object type, defaults to less<_Key>."},
{"lineNum":"   82","line":"   *  @tparam _Alloc  Allocator type, defaults to"},
{"lineNum":"   83","line":"   *                  allocator<pair<const _Key, _Tp>."},
{"lineNum":"   84","line":"   *"},
{"lineNum":"   85","line":"   *  Meets the requirements of a <a href=\"tables.html#65\">container</a>, a"},
{"lineNum":"   86","line":"   *  <a href=\"tables.html#66\">reversible container</a>, and an"},
{"lineNum":"   87","line":"   *  <a href=\"tables.html#69\">associative container</a> (using unique keys)."},
{"lineNum":"   88","line":"   *  For a @c map<Key,T> the key_type is Key, the mapped_type is T, and the"},
{"lineNum":"   89","line":"   *  value_type is std::pair<const Key,T>."},
{"lineNum":"   90","line":"   *"},
{"lineNum":"   91","line":"   *  Maps support bidirectional iterators."},
{"lineNum":"   92","line":"   *"},
{"lineNum":"   93","line":"   *  The private tree data is declared exactly the same way for map and"},
{"lineNum":"   94","line":"   *  multimap; the distinction is made entirely in how the tree functions are"},
{"lineNum":"   95","line":"   *  called (*_unique versus *_equal, same as the standard)."},
{"lineNum":"   96","line":"  */"},
{"lineNum":"   97","line":"  template <typename _Key, typename _Tp, typename _Compare = std::less<_Key>,"},
{"lineNum":"   98","line":"\t    typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >"},
{"lineNum":"   99","line":"    class map"},
{"lineNum":"  100","line":"    {"},
{"lineNum":"  101","line":"    public:"},
{"lineNum":"  102","line":"      typedef _Key\t\t\t\t\tkey_type;"},
{"lineNum":"  103","line":"      typedef _Tp\t\t\t\t\tmapped_type;"},
{"lineNum":"  104","line":"      typedef std::pair<const _Key, _Tp>\t\tvalue_type;"},
{"lineNum":"  105","line":"      typedef _Compare\t\t\t\t\tkey_compare;"},
{"lineNum":"  106","line":"      typedef _Alloc\t\t\t\t\tallocator_type;"},
{"lineNum":"  107","line":""},
{"lineNum":"  108","line":"    private:"},
{"lineNum":"  109","line":"#ifdef _GLIBCXX_CONCEPT_CHECKS"},
{"lineNum":"  110","line":"      // concept requirements"},
{"lineNum":"  111","line":"      typedef typename _Alloc::value_type\t\t_Alloc_value_type;"},
{"lineNum":"  112","line":"# if __cplusplus < 201103L"},
{"lineNum":"  113","line":"      __glibcxx_class_requires(_Tp, _SGIAssignableConcept)"},
{"lineNum":"  114","line":"# endif"},
{"lineNum":"  115","line":"      __glibcxx_class_requires4(_Compare, bool, _Key, _Key,"},
{"lineNum":"  116","line":"\t\t\t\t_BinaryFunctionConcept)"},
{"lineNum":"  117","line":"      __glibcxx_class_requires2(value_type, _Alloc_value_type, _SameTypeConcept)"},
{"lineNum":"  118","line":"#endif"},
{"lineNum":"  119","line":""},
{"lineNum":"  120","line":"    public:"},
{"lineNum":"  121","line":"      class value_compare"},
{"lineNum":"  122","line":"      : public std::binary_function<value_type, value_type, bool>"},
{"lineNum":"  123","line":"      {"},
{"lineNum":"  124","line":"\tfriend class map<_Key, _Tp, _Compare, _Alloc>;"},
{"lineNum":"  125","line":"      protected:"},
{"lineNum":"  126","line":"\t_Compare comp;"},
{"lineNum":"  127","line":""},
{"lineNum":"  128","line":"\tvalue_compare(_Compare __c)"},
{"lineNum":"  129","line":"\t: comp(__c) { }"},
{"lineNum":"  130","line":""},
{"lineNum":"  131","line":"      public:"},
{"lineNum":"  132","line":"\tbool operator()(const value_type& __x, const value_type& __y) const"},
{"lineNum":"  133","line":"\t{ return comp(__x.first, __y.first); }"},
{"lineNum":"  134","line":"      };"},
{"lineNum":"  135","line":""},
{"lineNum":"  136","line":"    private:"},
{"lineNum":"  137","line":"      /// This turns a red-black tree into a [multi]map."},
{"lineNum":"  138","line":"      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template"},
{"lineNum":"  139","line":"\trebind<value_type>::other _Pair_alloc_type;"},
{"lineNum":"  140","line":""},
{"lineNum":"  141","line":"      typedef _Rb_tree<key_type, value_type, _Select1st<value_type>,"},
{"lineNum":"  142","line":"\t\t       key_compare, _Pair_alloc_type> _Rep_type;"},
{"lineNum":"  143","line":""},
{"lineNum":"  144","line":"      /// The actual tree structure."},
{"lineNum":"  145","line":"      _Rep_type _M_t;"},
{"lineNum":"  146","line":""},
{"lineNum":"  147","line":"      typedef __gnu_cxx::__alloc_traits<_Pair_alloc_type> _Alloc_traits;"},
{"lineNum":"  148","line":""},
{"lineNum":"  149","line":"    public:"},
{"lineNum":"  150","line":"      // many of these are specified differently in ISO, but the following are"},
{"lineNum":"  151","line":"      // \"functionally equivalent\""},
{"lineNum":"  152","line":"      typedef typename _Alloc_traits::pointer\t\t pointer;"},
{"lineNum":"  153","line":"      typedef typename _Alloc_traits::const_pointer\t const_pointer;"},
{"lineNum":"  154","line":"      typedef typename _Alloc_traits::reference\t\t reference;"},
{"lineNum":"  155","line":"      typedef typename _Alloc_traits::const_reference\t const_reference;"},
{"lineNum":"  156","line":"      typedef typename _Rep_type::iterator\t\t iterator;"},
{"lineNum":"  157","line":"      typedef typename _Rep_type::const_iterator\t const_iterator;"},
{"lineNum":"  158","line":"      typedef typename _Rep_type::size_type\t\t size_type;"},
{"lineNum":"  159","line":"      typedef typename _Rep_type::difference_type\t difference_type;"},
{"lineNum":"  160","line":"      typedef typename _Rep_type::reverse_iterator\t reverse_iterator;"},
{"lineNum":"  161","line":"      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;"},
{"lineNum":"  162","line":""},
{"lineNum":"  163","line":"#if __cplusplus > 201402L"},
{"lineNum":"  164","line":"      using node_type = typename _Rep_type::node_type;"},
{"lineNum":"  165","line":"      using insert_return_type = typename _Rep_type::insert_return_type;"},
{"lineNum":"  166","line":"#endif"},
{"lineNum":"  167","line":""},
{"lineNum":"  168","line":"      // [23.3.1.1] construct/copy/destroy"},
{"lineNum":"  169","line":"      // (get_allocator() is also listed in this section)"},
{"lineNum":"  170","line":""},
{"lineNum":"  171","line":"      /**"},
{"lineNum":"  172","line":"       *  @brief  Default constructor creates no elements."},
{"lineNum":"  173","line":"       */"},
{"lineNum":"  174","line":"#if __cplusplus < 201103L"},
{"lineNum":"  175","line":"      map() : _M_t() { }"},
{"lineNum":"  176","line":"#else"},
{"lineNum":"  177","line":"      map() = default;","class":"linePartCov","hits":"2","order":"735","possible_hits":"3",},
{"lineNum":"  178","line":"#endif"},
{"lineNum":"  179","line":""},
{"lineNum":"  180","line":"      /**"},
{"lineNum":"  181","line":"       *  @brief  Creates a %map with no elements."},
{"lineNum":"  182","line":"       *  @param  __comp  A comparison object."},
{"lineNum":"  183","line":"       *  @param  __a  An allocator object."},
{"lineNum":"  184","line":"       */"},
{"lineNum":"  185","line":"      explicit"},
{"lineNum":"  186","line":"      map(const _Compare& __comp,"},
{"lineNum":"  187","line":"\t  const allocator_type& __a = allocator_type())"},
{"lineNum":"  188","line":"      : _M_t(__comp, _Pair_alloc_type(__a)) { }"},
{"lineNum":"  189","line":""},
{"lineNum":"  190","line":"      /**"},
{"lineNum":"  191","line":"       *  @brief  %Map copy constructor."},
{"lineNum":"  192","line":"       *"},
{"lineNum":"  193","line":"       *  Whether the allocator is copied depends on the allocator traits."},
{"lineNum":"  194","line":"       */"},
{"lineNum":"  195","line":"#if __cplusplus < 201103L"},
{"lineNum":"  196","line":"      map(const map& __x)"},
{"lineNum":"  197","line":"      : _M_t(__x._M_t) { }"},
{"lineNum":"  198","line":"#else"},
{"lineNum":"  199","line":"      map(const map&) = default;","class":"linePartCov","hits":"2","order":"1075","possible_hits":"3",},
{"lineNum":"  200","line":""},
{"lineNum":"  201","line":"      /**"},
{"lineNum":"  202","line":"       *  @brief  %Map move constructor."},
{"lineNum":"  203","line":"       *"},
{"lineNum":"  204","line":"       *  The newly-created %map contains the exact contents of the moved"},
{"lineNum":"  205","line":"       *  instance. The moved instance is a valid, but unspecified, %map."},
{"lineNum":"  206","line":"       */"},
{"lineNum":"  207","line":"      map(map&&) = default;","class":"linePartCov","hits":"2","order":"768","possible_hits":"3",},
{"lineNum":"  208","line":""},
{"lineNum":"  209","line":"      /**"},
{"lineNum":"  210","line":"       *  @brief  Builds a %map from an initializer_list."},
{"lineNum":"  211","line":"       *  @param  __l  An initializer_list."},
{"lineNum":"  212","line":"       *  @param  __comp  A comparison object."},
{"lineNum":"  213","line":"       *  @param  __a  An allocator object."},
{"lineNum":"  214","line":"       *"},
{"lineNum":"  215","line":"       *  Create a %map consisting of copies of the elements in the"},
{"lineNum":"  216","line":"       *  initializer_list @a __l."},
{"lineNum":"  217","line":"       *  This is linear in N if the range is already sorted, and NlogN"},
{"lineNum":"  218","line":"       *  otherwise (where N is @a __l.size())."},
{"lineNum":"  219","line":"       */"},
{"lineNum":"  220","line":"      map(initializer_list<value_type> __l,"},
{"lineNum":"  221","line":"\t  const _Compare& __comp = _Compare(),"},
{"lineNum":"  222","line":"\t  const allocator_type& __a = allocator_type())"},
{"lineNum":"  223","line":"      : _M_t(__comp, _Pair_alloc_type(__a))"},
{"lineNum":"  224","line":"      { _M_t._M_insert_unique(__l.begin(), __l.end()); }"},
{"lineNum":"  225","line":""},
{"lineNum":"  226","line":"      /// Allocator-extended default constructor."},
{"lineNum":"  227","line":"      explicit"},
{"lineNum":"  228","line":"      map(const allocator_type& __a)"},
{"lineNum":"  229","line":"      : _M_t(_Compare(), _Pair_alloc_type(__a)) { }"},
{"lineNum":"  230","line":""},
{"lineNum":"  231","line":"      /// Allocator-extended copy constructor."},
{"lineNum":"  232","line":"      map(const map& __m, const allocator_type& __a)"},
{"lineNum":"  233","line":"      : _M_t(__m._M_t, _Pair_alloc_type(__a)) { }"},
{"lineNum":"  234","line":""},
{"lineNum":"  235","line":"      /// Allocator-extended move constructor."},
{"lineNum":"  236","line":"      map(map&& __m, const allocator_type& __a)"},
{"lineNum":"  237","line":"      noexcept(is_nothrow_copy_constructible<_Compare>::value"},
{"lineNum":"  238","line":"\t       && _Alloc_traits::_S_always_equal())"},
{"lineNum":"  239","line":"      : _M_t(std::move(__m._M_t), _Pair_alloc_type(__a)) { }"},
{"lineNum":"  240","line":""},
{"lineNum":"  241","line":"      /// Allocator-extended initialier-list constructor."},
{"lineNum":"  242","line":"      map(initializer_list<value_type> __l, const allocator_type& __a)"},
{"lineNum":"  243","line":"      : _M_t(_Compare(), _Pair_alloc_type(__a))"},
{"lineNum":"  244","line":"      { _M_t._M_insert_unique(__l.begin(), __l.end()); }"},
{"lineNum":"  245","line":""},
{"lineNum":"  246","line":"      /// Allocator-extended range constructor."},
{"lineNum":"  247","line":"      template<typename _InputIterator>"},
{"lineNum":"  248","line":"\tmap(_InputIterator __first, _InputIterator __last,"},
{"lineNum":"  249","line":"\t    const allocator_type& __a)"},
{"lineNum":"  250","line":"\t: _M_t(_Compare(), _Pair_alloc_type(__a))"},
{"lineNum":"  251","line":"\t{ _M_t._M_insert_unique(__first, __last); }"},
{"lineNum":"  252","line":"#endif"},
{"lineNum":"  253","line":""},
{"lineNum":"  254","line":"      /**"},
{"lineNum":"  255","line":"       *  @brief  Builds a %map from a range."},
{"lineNum":"  256","line":"       *  @param  __first  An input iterator."},
{"lineNum":"  257","line":"       *  @param  __last  An input iterator."},
{"lineNum":"  258","line":"       *"},
{"lineNum":"  259","line":"       *  Create a %map consisting of copies of the elements from"},
{"lineNum":"  260","line":"       *  [__first,__last).  This is linear in N if the range is"},
{"lineNum":"  261","line":"       *  already sorted, and NlogN otherwise (where N is"},
{"lineNum":"  262","line":"       *  distance(__first,__last))."},
{"lineNum":"  263","line":"       */"},
{"lineNum":"  264","line":"      template<typename _InputIterator>"},
{"lineNum":"  265","line":"\tmap(_InputIterator __first, _InputIterator __last)"},
{"lineNum":"  266","line":"\t: _M_t()"},
{"lineNum":"  267","line":"\t{ _M_t._M_insert_unique(__first, __last); }"},
{"lineNum":"  268","line":""},
{"lineNum":"  269","line":"      /**"},
{"lineNum":"  270","line":"       *  @brief  Builds a %map from a range."},
{"lineNum":"  271","line":"       *  @param  __first  An input iterator."},
{"lineNum":"  272","line":"       *  @param  __last  An input iterator."},
{"lineNum":"  273","line":"       *  @param  __comp  A comparison functor."},
{"lineNum":"  274","line":"       *  @param  __a  An allocator object."},
{"lineNum":"  275","line":"       *"},
{"lineNum":"  276","line":"       *  Create a %map consisting of copies of the elements from"},
{"lineNum":"  277","line":"       *  [__first,__last).  This is linear in N if the range is"},
{"lineNum":"  278","line":"       *  already sorted, and NlogN otherwise (where N is"},
{"lineNum":"  279","line":"       *  distance(__first,__last))."},
{"lineNum":"  280","line":"       */"},
{"lineNum":"  281","line":"      template<typename _InputIterator>"},
{"lineNum":"  282","line":"\tmap(_InputIterator __first, _InputIterator __last,"},
{"lineNum":"  283","line":"\t    const _Compare& __comp,"},
{"lineNum":"  284","line":"\t    const allocator_type& __a = allocator_type())"},
{"lineNum":"  285","line":"\t: _M_t(__comp, _Pair_alloc_type(__a))"},
{"lineNum":"  286","line":"\t{ _M_t._M_insert_unique(__first, __last); }"},
{"lineNum":"  287","line":""},
{"lineNum":"  288","line":"#if __cplusplus >= 201103L"},
{"lineNum":"  289","line":"      /**"},
{"lineNum":"  290","line":"       *  The dtor only erases the elements, and note that if the elements"},
{"lineNum":"  291","line":"       *  themselves are pointers, the pointed-to memory is not touched in any"},
{"lineNum":"  292","line":"       *  way.  Managing the pointer is the user\'s responsibility."},
{"lineNum":"  293","line":"       */"},
{"lineNum":"  294","line":"      ~map() = default;","class":"linePartCov","hits":"2","order":"783","possible_hits":"3",},
{"lineNum":"  295","line":"#endif"},
{"lineNum":"  296","line":""},
{"lineNum":"  297","line":"      /**"},
{"lineNum":"  298","line":"       *  @brief  %Map assignment operator."},
{"lineNum":"  299","line":"       *"},
{"lineNum":"  300","line":"       *  Whether the allocator is copied depends on the allocator traits."},
{"lineNum":"  301","line":"       */"},
{"lineNum":"  302","line":"#if __cplusplus < 201103L"},
{"lineNum":"  303","line":"      map&"},
{"lineNum":"  304","line":"      operator=(const map& __x)"},
{"lineNum":"  305","line":"      {"},
{"lineNum":"  306","line":"\t_M_t = __x._M_t;"},
{"lineNum":"  307","line":"\treturn *this;"},
{"lineNum":"  308","line":"      }"},
{"lineNum":"  309","line":"#else"},
{"lineNum":"  310","line":"      map&"},
{"lineNum":"  311","line":"      operator=(const map&) = default;"},
{"lineNum":"  312","line":""},
{"lineNum":"  313","line":"      /// Move assignment operator."},
{"lineNum":"  314","line":"      map&"},
{"lineNum":"  315","line":"      operator=(map&&) = default;"},
{"lineNum":"  316","line":""},
{"lineNum":"  317","line":"      /**"},
{"lineNum":"  318","line":"       *  @brief  %Map list assignment operator."},
{"lineNum":"  319","line":"       *  @param  __l  An initializer_list."},
{"lineNum":"  320","line":"       *"},
{"lineNum":"  321","line":"       *  This function fills a %map with copies of the elements in the"},
{"lineNum":"  322","line":"       *  initializer list @a __l."},
{"lineNum":"  323","line":"       *"},
{"lineNum":"  324","line":"       *  Note that the assignment completely changes the %map and"},
{"lineNum":"  325","line":"       *  that the resulting %map\'s size is the same as the number"},
{"lineNum":"  326","line":"       *  of elements assigned."},
{"lineNum":"  327","line":"       */"},
{"lineNum":"  328","line":"      map&"},
{"lineNum":"  329","line":"      operator=(initializer_list<value_type> __l)"},
{"lineNum":"  330","line":"      {"},
{"lineNum":"  331","line":"\t_M_t._M_assign_unique(__l.begin(), __l.end());"},
{"lineNum":"  332","line":"\treturn *this;"},
{"lineNum":"  333","line":"      }"},
{"lineNum":"  334","line":"#endif"},
{"lineNum":"  335","line":""},
{"lineNum":"  336","line":"      /// Get a copy of the memory allocation object."},
{"lineNum":"  337","line":"      allocator_type"},
{"lineNum":"  338","line":"      get_allocator() const _GLIBCXX_NOEXCEPT"},
{"lineNum":"  339","line":"      { return allocator_type(_M_t.get_allocator()); }"},
{"lineNum":"  340","line":""},
{"lineNum":"  341","line":"      // iterators"},
{"lineNum":"  342","line":"      /**"},
{"lineNum":"  343","line":"       *  Returns a read/write iterator that points to the first pair in the"},
{"lineNum":"  344","line":"       *  %map."},
{"lineNum":"  345","line":"       *  Iteration is done in ascending order according to the keys."},
{"lineNum":"  346","line":"       */"},
{"lineNum":"  347","line":"      iterator"},
{"lineNum":"  348","line":"      begin() _GLIBCXX_NOEXCEPT"},
{"lineNum":"  349","line":"      { return _M_t.begin(); }"},
{"lineNum":"  350","line":""},
{"lineNum":"  351","line":"      /**"},
{"lineNum":"  352","line":"       *  Returns a read-only (constant) iterator that points to the first pair"},
{"lineNum":"  353","line":"       *  in the %map.  Iteration is done in ascending order according to the"},
{"lineNum":"  354","line":"       *  keys."},
{"lineNum":"  355","line":"       */"},
{"lineNum":"  356","line":"      const_iterator"},
{"lineNum":"  357","line":"      begin() const _GLIBCXX_NOEXCEPT"},
{"lineNum":"  358","line":"      { return _M_t.begin(); }"},
{"lineNum":"  359","line":""},
{"lineNum":"  360","line":"      /**"},
{"lineNum":"  361","line":"       *  Returns a read/write iterator that points one past the last"},
{"lineNum":"  362","line":"       *  pair in the %map.  Iteration is done in ascending order"},
{"lineNum":"  363","line":"       *  according to the keys."},
{"lineNum":"  364","line":"       */"},
{"lineNum":"  365","line":"      iterator"},
{"lineNum":"  366","line":"      end() _GLIBCXX_NOEXCEPT","class":"lineCov","hits":"1","order":"874","possible_hits":"1",},
{"lineNum":"  367","line":"      { return _M_t.end(); }","class":"linePartCov","hits":"1","order":"875","possible_hits":"2",},
{"lineNum":"  368","line":""},
{"lineNum":"  369","line":"      /**"},
{"lineNum":"  370","line":"       *  Returns a read-only (constant) iterator that points one past the last"},
{"lineNum":"  371","line":"       *  pair in the %map.  Iteration is done in ascending order according to"},
{"lineNum":"  372","line":"       *  the keys."},
{"lineNum":"  373","line":"       */"},
{"lineNum":"  374","line":"      const_iterator"},
{"lineNum":"  375","line":"      end() const _GLIBCXX_NOEXCEPT"},
{"lineNum":"  376","line":"      { return _M_t.end(); }"},
{"lineNum":"  377","line":""},
{"lineNum":"  378","line":"      /**"},
{"lineNum":"  379","line":"       *  Returns a read/write reverse iterator that points to the last pair in"},
{"lineNum":"  380","line":"       *  the %map.  Iteration is done in descending order according to the"},
{"lineNum":"  381","line":"       *  keys."},
{"lineNum":"  382","line":"       */"},
{"lineNum":"  383","line":"      reverse_iterator"},
{"lineNum":"  384","line":"      rbegin() _GLIBCXX_NOEXCEPT"},
{"lineNum":"  385","line":"      { return _M_t.rbegin(); }"},
{"lineNum":"  386","line":""},
{"lineNum":"  387","line":"      /**"},
{"lineNum":"  388","line":"       *  Returns a read-only (constant) reverse iterator that points to the"},
{"lineNum":"  389","line":"       *  last pair in the %map.  Iteration is done in descending order"},
{"lineNum":"  390","line":"       *  according to the keys."},
{"lineNum":"  391","line":"       */"},
{"lineNum":"  392","line":"      const_reverse_iterator"},
{"lineNum":"  393","line":"      rbegin() const _GLIBCXX_NOEXCEPT"},
{"lineNum":"  394","line":"      { return _M_t.rbegin(); }"},
{"lineNum":"  395","line":""},
{"lineNum":"  396","line":"      /**"},
{"lineNum":"  397","line":"       *  Returns a read/write reverse iterator that points to one before the"},
{"lineNum":"  398","line":"       *  first pair in the %map.  Iteration is done in descending order"},
{"lineNum":"  399","line":"       *  according to the keys."},
{"lineNum":"  400","line":"       */"},
{"lineNum":"  401","line":"      reverse_iterator"},
{"lineNum":"  402","line":"      rend() _GLIBCXX_NOEXCEPT"},
{"lineNum":"  403","line":"      { return _M_t.rend(); }"},
{"lineNum":"  404","line":""},
{"lineNum":"  405","line":"      /**"},
{"lineNum":"  406","line":"       *  Returns a read-only (constant) reverse iterator that points to one"},
{"lineNum":"  407","line":"       *  before the first pair in the %map.  Iteration is done in descending"},
{"lineNum":"  408","line":"       *  order according to the keys."},
{"lineNum":"  409","line":"       */"},
{"lineNum":"  410","line":"      const_reverse_iterator"},
{"lineNum":"  411","line":"      rend() const _GLIBCXX_NOEXCEPT"},
{"lineNum":"  412","line":"      { return _M_t.rend(); }"},
{"lineNum":"  413","line":""},
{"lineNum":"  414","line":"#if __cplusplus >= 201103L"},
{"lineNum":"  415","line":"      /**"},
{"lineNum":"  416","line":"       *  Returns a read-only (constant) iterator that points to the first pair"},
{"lineNum":"  417","line":"       *  in the %map.  Iteration is done in ascending order according to the"},
{"lineNum":"  418","line":"       *  keys."},
{"lineNum":"  419","line":"       */"},
{"lineNum":"  420","line":"      const_iterator"},
{"lineNum":"  421","line":"      cbegin() const noexcept"},
{"lineNum":"  422","line":"      { return _M_t.begin(); }"},
{"lineNum":"  423","line":""},
{"lineNum":"  424","line":"      /**"},
{"lineNum":"  425","line":"       *  Returns a read-only (constant) iterator that points one past the last"},
{"lineNum":"  426","line":"       *  pair in the %map.  Iteration is done in ascending order according to"},
{"lineNum":"  427","line":"       *  the keys."},
{"lineNum":"  428","line":"       */"},
{"lineNum":"  429","line":"      const_iterator"},
{"lineNum":"  430","line":"      cend() const noexcept"},
{"lineNum":"  431","line":"      { return _M_t.end(); }"},
{"lineNum":"  432","line":""},
{"lineNum":"  433","line":"      /**"},
{"lineNum":"  434","line":"       *  Returns a read-only (constant) reverse iterator that points to the"},
{"lineNum":"  435","line":"       *  last pair in the %map.  Iteration is done in descending order"},
{"lineNum":"  436","line":"       *  according to the keys."},
{"lineNum":"  437","line":"       */"},
{"lineNum":"  438","line":"      const_reverse_iterator"},
{"lineNum":"  439","line":"      crbegin() const noexcept"},
{"lineNum":"  440","line":"      { return _M_t.rbegin(); }"},
{"lineNum":"  441","line":""},
{"lineNum":"  442","line":"      /**"},
{"lineNum":"  443","line":"       *  Returns a read-only (constant) reverse iterator that points to one"},
{"lineNum":"  444","line":"       *  before the first pair in the %map.  Iteration is done in descending"},
{"lineNum":"  445","line":"       *  order according to the keys."},
{"lineNum":"  446","line":"       */"},
{"lineNum":"  447","line":"      const_reverse_iterator"},
{"lineNum":"  448","line":"      crend() const noexcept"},
{"lineNum":"  449","line":"      { return _M_t.rend(); }"},
{"lineNum":"  450","line":"#endif"},
{"lineNum":"  451","line":""},
{"lineNum":"  452","line":"      // capacity"},
{"lineNum":"  453","line":"      /** Returns true if the %map is empty.  (Thus begin() would equal"},
{"lineNum":"  454","line":"       *  end().)"},
{"lineNum":"  455","line":"      */"},
{"lineNum":"  456","line":"      bool"},
{"lineNum":"  457","line":"      empty() const _GLIBCXX_NOEXCEPT"},
{"lineNum":"  458","line":"      { return _M_t.empty(); }"},
{"lineNum":"  459","line":""},
{"lineNum":"  460","line":"      /** Returns the size of the %map.  */"},
{"lineNum":"  461","line":"      size_type"},
{"lineNum":"  462","line":"      size() const _GLIBCXX_NOEXCEPT"},
{"lineNum":"  463","line":"      { return _M_t.size(); }"},
{"lineNum":"  464","line":""},
{"lineNum":"  465","line":"      /** Returns the maximum size of the %map.  */"},
{"lineNum":"  466","line":"      size_type"},
{"lineNum":"  467","line":"      max_size() const _GLIBCXX_NOEXCEPT"},
{"lineNum":"  468","line":"      { return _M_t.max_size(); }"},
{"lineNum":"  469","line":""},
{"lineNum":"  470","line":"      // [23.3.1.2] element access"},
{"lineNum":"  471","line":"      /**"},
{"lineNum":"  472","line":"       *  @brief  Subscript ( @c [] ) access to %map data."},
{"lineNum":"  473","line":"       *  @param  __k  The key for which data should be retrieved."},
{"lineNum":"  474","line":"       *  @return  A reference to the data of the (key,data) %pair."},
{"lineNum":"  475","line":"       *"},
{"lineNum":"  476","line":"       *  Allows for easy lookup with the subscript ( @c [] )"},
{"lineNum":"  477","line":"       *  operator.  Returns data associated with the key specified in"},
{"lineNum":"  478","line":"       *  subscript.  If the key does not exist, a pair with that key"},
{"lineNum":"  479","line":"       *  is created using default values, which is then returned."},
{"lineNum":"  480","line":"       *"},
{"lineNum":"  481","line":"       *  Lookup requires logarithmic time."},
{"lineNum":"  482","line":"       */"},
{"lineNum":"  483","line":"      mapped_type&"},
{"lineNum":"  484","line":"      operator[](const key_type& __k)"},
{"lineNum":"  485","line":"      {"},
{"lineNum":"  486","line":"\t// concept requirements"},
{"lineNum":"  487","line":"\t__glibcxx_function_requires(_DefaultConstructibleConcept<mapped_type>)"},
{"lineNum":"  488","line":""},
{"lineNum":"  489","line":"\titerator __i = lower_bound(__k);"},
{"lineNum":"  490","line":"\t// __i->first is greater than or equivalent to __k."},
{"lineNum":"  491","line":"\tif (__i == end() || key_comp()(__k, (*__i).first))"},
{"lineNum":"  492","line":"#if __cplusplus >= 201103L"},
{"lineNum":"  493","line":"\t  __i = _M_t._M_emplace_hint_unique(__i, std::piecewise_construct,"},
{"lineNum":"  494","line":"\t\t\t\t\t    std::tuple<const key_type&>(__k),"},
{"lineNum":"  495","line":"\t\t\t\t\t    std::tuple<>());"},
{"lineNum":"  496","line":"#else"},
{"lineNum":"  497","line":"\t  __i = insert(__i, value_type(__k, mapped_type()));"},
{"lineNum":"  498","line":"#endif"},
{"lineNum":"  499","line":"\treturn (*__i).second;"},
{"lineNum":"  500","line":"      }"},
{"lineNum":"  501","line":""},
{"lineNum":"  502","line":"#if __cplusplus >= 201103L"},
{"lineNum":"  503","line":"      mapped_type&"},
{"lineNum":"  504","line":"      operator[](key_type&& __k)"},
{"lineNum":"  505","line":"      {"},
{"lineNum":"  506","line":"\t// concept requirements"},
{"lineNum":"  507","line":"\t__glibcxx_function_requires(_DefaultConstructibleConcept<mapped_type>)"},
{"lineNum":"  508","line":""},
{"lineNum":"  509","line":"\titerator __i = lower_bound(__k);"},
{"lineNum":"  510","line":"\t// __i->first is greater than or equivalent to __k."},
{"lineNum":"  511","line":"\tif (__i == end() || key_comp()(__k, (*__i).first))"},
{"lineNum":"  512","line":"\t  __i = _M_t._M_emplace_hint_unique(__i, std::piecewise_construct,"},
{"lineNum":"  513","line":"\t\t\t\t\tstd::forward_as_tuple(std::move(__k)),"},
{"lineNum":"  514","line":"\t\t\t\t\tstd::tuple<>());"},
{"lineNum":"  515","line":"\treturn (*__i).second;"},
{"lineNum":"  516","line":"      }"},
{"lineNum":"  517","line":"#endif"},
{"lineNum":"  518","line":""},
{"lineNum":"  519","line":"      // _GLIBCXX_RESOLVE_LIB_DEFECTS"},
{"lineNum":"  520","line":"      // DR 464. Suggestion for new member functions in standard containers."},
{"lineNum":"  521","line":"      /**"},
{"lineNum":"  522","line":"       *  @brief  Access to %map data."},
{"lineNum":"  523","line":"       *  @param  __k  The key for which data should be retrieved."},
{"lineNum":"  524","line":"       *  @return  A reference to the data whose key is equivalent to @a __k, if"},
{"lineNum":"  525","line":"       *           such a data is present in the %map."},
{"lineNum":"  526","line":"       *  @throw  std::out_of_range  If no such data is present."},
{"lineNum":"  527","line":"       */"},
{"lineNum":"  528","line":"      mapped_type&"},
{"lineNum":"  529","line":"      at(const key_type& __k)"},
{"lineNum":"  530","line":"      {"},
{"lineNum":"  531","line":"\titerator __i = lower_bound(__k);"},
{"lineNum":"  532","line":"\tif (__i == end() || key_comp()(__k, (*__i).first))"},
{"lineNum":"  533","line":"\t  __throw_out_of_range(__N(\"map::at\"));"},
{"lineNum":"  534","line":"\treturn (*__i).second;"},
{"lineNum":"  535","line":"      }"},
{"lineNum":"  536","line":""},
{"lineNum":"  537","line":"      const mapped_type&"},
{"lineNum":"  538","line":"      at(const key_type& __k) const"},
{"lineNum":"  539","line":"      {"},
{"lineNum":"  540","line":"\tconst_iterator __i = lower_bound(__k);"},
{"lineNum":"  541","line":"\tif (__i == end() || key_comp()(__k, (*__i).first))"},
{"lineNum":"  542","line":"\t  __throw_out_of_range(__N(\"map::at\"));"},
{"lineNum":"  543","line":"\treturn (*__i).second;"},
{"lineNum":"  544","line":"      }"},
{"lineNum":"  545","line":""},
{"lineNum":"  546","line":"      // modifiers"},
{"lineNum":"  547","line":"#if __cplusplus >= 201103L"},
{"lineNum":"  548","line":"      /**"},
{"lineNum":"  549","line":"       *  @brief Attempts to build and insert a std::pair into the %map."},
{"lineNum":"  550","line":"       *"},
{"lineNum":"  551","line":"       *  @param __args  Arguments used to generate a new pair instance (see"},
{"lineNum":"  552","line":"       *\t        std::piecewise_contruct for passing arguments to each"},
{"lineNum":"  553","line":"       *\t        part of the pair constructor)."},
{"lineNum":"  554","line":"       *"},
{"lineNum":"  555","line":"       *  @return  A pair, of which the first element is an iterator that points"},
{"lineNum":"  556","line":"       *           to the possibly inserted pair, and the second is a bool that"},
{"lineNum":"  557","line":"       *           is true if the pair was actually inserted."},
{"lineNum":"  558","line":"       *"},
{"lineNum":"  559","line":"       *  This function attempts to build and insert a (key, value) %pair into"},
{"lineNum":"  560","line":"       *  the %map."},
{"lineNum":"  561","line":"       *  A %map relies on unique keys and thus a %pair is only inserted if its"},
{"lineNum":"  562","line":"       *  first element (the key) is not already present in the %map."},
{"lineNum":"  563","line":"       *"},
{"lineNum":"  564","line":"       *  Insertion requires logarithmic time."},
{"lineNum":"  565","line":"       */"},
{"lineNum":"  566","line":"      template<typename... _Args>"},
{"lineNum":"  567","line":"\tstd::pair<iterator, bool>"},
{"lineNum":"  568","line":"\templace(_Args&&... __args)"},
{"lineNum":"  569","line":"\t{ return _M_t._M_emplace_unique(std::forward<_Args>(__args)...); }"},
{"lineNum":"  570","line":""},
{"lineNum":"  571","line":"      /**"},
{"lineNum":"  572","line":"       *  @brief Attempts to build and insert a std::pair into the %map."},
{"lineNum":"  573","line":"       *"},
{"lineNum":"  574","line":"       *  @param  __pos  An iterator that serves as a hint as to where the pair"},
{"lineNum":"  575","line":"       *                should be inserted."},
{"lineNum":"  576","line":"       *  @param  __args  Arguments used to generate a new pair instance (see"},
{"lineNum":"  577","line":"       *\t         std::piecewise_contruct for passing arguments to each"},
{"lineNum":"  578","line":"       *\t         part of the pair constructor)."},
{"lineNum":"  579","line":"       *  @return An iterator that points to the element with key of the"},
{"lineNum":"  580","line":"       *          std::pair built from @a __args (may or may not be that"},
{"lineNum":"  581","line":"       *          std::pair)."},
{"lineNum":"  582","line":"       *"},
{"lineNum":"  583","line":"       *  This function is not concerned about whether the insertion took place,"},
{"lineNum":"  584","line":"       *  and thus does not return a boolean like the single-argument emplace()"},
{"lineNum":"  585","line":"       *  does."},
{"lineNum":"  586","line":"       *  Note that the first parameter is only a hint and can potentially"},
{"lineNum":"  587","line":"       *  improve the performance of the insertion process. A bad hint would"},
{"lineNum":"  588","line":"       *  cause no gains in efficiency."},
{"lineNum":"  589","line":"       *"},
{"lineNum":"  590","line":"       *  See"},
{"lineNum":"  591","line":"       *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints"},
{"lineNum":"  592","line":"       *  for more on @a hinting."},
{"lineNum":"  593","line":"       *"},
{"lineNum":"  594","line":"       *  Insertion requires logarithmic time (if the hint is not taken)."},
{"lineNum":"  595","line":"       */"},
{"lineNum":"  596","line":"      template<typename... _Args>"},
{"lineNum":"  597","line":"\titerator"},
{"lineNum":"  598","line":"\templace_hint(const_iterator __pos, _Args&&... __args)"},
{"lineNum":"  599","line":"\t{"},
{"lineNum":"  600","line":"\t  return _M_t._M_emplace_hint_unique(__pos,"},
{"lineNum":"  601","line":"\t\t\t\t\t     std::forward<_Args>(__args)...);"},
{"lineNum":"  602","line":"\t}"},
{"lineNum":"  603","line":"#endif"},
{"lineNum":"  604","line":""},
{"lineNum":"  605","line":"#if __cplusplus > 201402L"},
{"lineNum":"  606","line":"      /// Extract a node."},
{"lineNum":"  607","line":"      node_type"},
{"lineNum":"  608","line":"      extract(const_iterator __pos)"},
{"lineNum":"  609","line":"      {"},
{"lineNum":"  610","line":"\t__glibcxx_assert(__pos != end());"},
{"lineNum":"  611","line":"\treturn _M_t.extract(__pos);"},
{"lineNum":"  612","line":"      }"},
{"lineNum":"  613","line":""},
{"lineNum":"  614","line":"      /// Extract a node."},
{"lineNum":"  615","line":"      node_type"},
{"lineNum":"  616","line":"      extract(const key_type& __x)"},
{"lineNum":"  617","line":"      { return _M_t.extract(__x); }"},
{"lineNum":"  618","line":""},
{"lineNum":"  619","line":"      /// Re-insert an extracted node."},
{"lineNum":"  620","line":"      insert_return_type"},
{"lineNum":"  621","line":"      insert(node_type&& __nh)"},
{"lineNum":"  622","line":"      { return _M_t._M_reinsert_node_unique(std::move(__nh)); }"},
{"lineNum":"  623","line":""},
{"lineNum":"  624","line":"      /// Re-insert an extracted node."},
{"lineNum":"  625","line":"      iterator"},
{"lineNum":"  626","line":"      insert(const_iterator __hint, node_type&& __nh)"},
{"lineNum":"  627","line":"      { return _M_t._M_reinsert_node_hint_unique(__hint, std::move(__nh)); }"},
{"lineNum":"  628","line":""},
{"lineNum":"  629","line":"      template<typename, typename>"},
{"lineNum":"  630","line":"\tfriend class _Rb_tree_merge_helper;"},
{"lineNum":"  631","line":""},
{"lineNum":"  632","line":"      template<typename _C2>"},
{"lineNum":"  633","line":"\tvoid"},
{"lineNum":"  634","line":"\tmerge(map<_Key, _Tp, _C2, _Alloc>& __source)"},
{"lineNum":"  635","line":"\t{"},
{"lineNum":"  636","line":"\t  using _Merge_helper = _Rb_tree_merge_helper<map, _C2>;"},
{"lineNum":"  637","line":"\t  _M_t._M_merge_unique(_Merge_helper::_S_get_tree(__source));"},
{"lineNum":"  638","line":"\t}"},
{"lineNum":"  639","line":""},
{"lineNum":"  640","line":"      template<typename _C2>"},
{"lineNum":"  641","line":"\tvoid"},
{"lineNum":"  642","line":"\tmerge(map<_Key, _Tp, _C2, _Alloc>&& __source)"},
{"lineNum":"  643","line":"\t{ merge(__source); }"},
{"lineNum":"  644","line":""},
{"lineNum":"  645","line":"      template<typename _C2>"},
{"lineNum":"  646","line":"\tvoid"},
{"lineNum":"  647","line":"\tmerge(multimap<_Key, _Tp, _C2, _Alloc>& __source)"},
{"lineNum":"  648","line":"\t{"},
{"lineNum":"  649","line":"\t  using _Merge_helper = _Rb_tree_merge_helper<map, _C2>;"},
{"lineNum":"  650","line":"\t  _M_t._M_merge_unique(_Merge_helper::_S_get_tree(__source));"},
{"lineNum":"  651","line":"\t}"},
{"lineNum":"  652","line":""},
{"lineNum":"  653","line":"      template<typename _C2>"},
{"lineNum":"  654","line":"\tvoid"},
{"lineNum":"  655","line":"\tmerge(multimap<_Key, _Tp, _C2, _Alloc>&& __source)"},
{"lineNum":"  656","line":"\t{ merge(__source); }"},
{"lineNum":"  657","line":"#endif // C++17"},
{"lineNum":"  658","line":""},
{"lineNum":"  659","line":"#if __cplusplus > 201402L"},
{"lineNum":"  660","line":"#define __cpp_lib_map_try_emplace 201411"},
{"lineNum":"  661","line":"      /**"},
{"lineNum":"  662","line":"       *  @brief Attempts to build and insert a std::pair into the %map."},
{"lineNum":"  663","line":"       *"},
{"lineNum":"  664","line":"       *  @param __k    Key to use for finding a possibly existing pair in"},
{"lineNum":"  665","line":"       *                the map."},
{"lineNum":"  666","line":"       *  @param __args  Arguments used to generate the .second for a new pair"},
{"lineNum":"  667","line":"       *                instance."},
{"lineNum":"  668","line":"       *"},
{"lineNum":"  669","line":"       *  @return  A pair, of which the first element is an iterator that points"},
{"lineNum":"  670","line":"       *           to the possibly inserted pair, and the second is a bool that"},
{"lineNum":"  671","line":"       *           is true if the pair was actually inserted."},
{"lineNum":"  672","line":"       *"},
{"lineNum":"  673","line":"       *  This function attempts to build and insert a (key, value) %pair into"},
{"lineNum":"  674","line":"       *  the %map."},
{"lineNum":"  675","line":"       *  A %map relies on unique keys and thus a %pair is only inserted if its"},
{"lineNum":"  676","line":"       *  first element (the key) is not already present in the %map."},
{"lineNum":"  677","line":"       *  If a %pair is not inserted, this function has no effect."},
{"lineNum":"  678","line":"       *"},
{"lineNum":"  679","line":"       *  Insertion requires logarithmic time."},
{"lineNum":"  680","line":"       */"},
{"lineNum":"  681","line":"      template <typename... _Args>"},
{"lineNum":"  682","line":"\tpair<iterator, bool>"},
{"lineNum":"  683","line":"\ttry_emplace(const key_type& __k, _Args&&... __args)"},
{"lineNum":"  684","line":"\t{"},
{"lineNum":"  685","line":"\t  iterator __i = lower_bound(__k);"},
{"lineNum":"  686","line":"\t  if (__i == end() || key_comp()(__k, (*__i).first))"},
{"lineNum":"  687","line":"\t    {"},
{"lineNum":"  688","line":"\t      __i = emplace_hint(__i, std::piecewise_construct,"},
{"lineNum":"  689","line":"\t\t\t\t std::forward_as_tuple(__k),"},
{"lineNum":"  690","line":"\t\t\t\t std::forward_as_tuple("},
{"lineNum":"  691","line":"\t\t\t\t   std::forward<_Args>(__args)...));"},
{"lineNum":"  692","line":"\t      return {__i, true};"},
{"lineNum":"  693","line":"\t    }"},
{"lineNum":"  694","line":"\t  return {__i, false};"},
{"lineNum":"  695","line":"\t}"},
{"lineNum":"  696","line":""},
{"lineNum":"  697","line":"      // move-capable overload"},
{"lineNum":"  698","line":"      template <typename... _Args>"},
{"lineNum":"  699","line":"\tpair<iterator, bool>"},
{"lineNum":"  700","line":"\ttry_emplace(key_type&& __k, _Args&&... __args)"},
{"lineNum":"  701","line":"\t{"},
{"lineNum":"  702","line":"\t  iterator __i = lower_bound(__k);"},
{"lineNum":"  703","line":"\t  if (__i == end() || key_comp()(__k, (*__i).first))"},
{"lineNum":"  704","line":"\t    {"},
{"lineNum":"  705","line":"\t      __i = emplace_hint(__i, std::piecewise_construct,"},
{"lineNum":"  706","line":"\t\t\t\t std::forward_as_tuple(std::move(__k)),"},
{"lineNum":"  707","line":"\t\t\t\t std::forward_as_tuple("},
{"lineNum":"  708","line":"\t\t\t\t   std::forward<_Args>(__args)...));"},
{"lineNum":"  709","line":"\t      return {__i, true};"},
{"lineNum":"  710","line":"\t    }"},
{"lineNum":"  711","line":"\t  return {__i, false};"},
{"lineNum":"  712","line":"\t}"},
{"lineNum":"  713","line":""},
{"lineNum":"  714","line":"      /**"},
{"lineNum":"  715","line":"       *  @brief Attempts to build and insert a std::pair into the %map."},
{"lineNum":"  716","line":"       *"},
{"lineNum":"  717","line":"       *  @param  __hint  An iterator that serves as a hint as to where the"},
{"lineNum":"  718","line":"       *                  pair should be inserted."},
{"lineNum":"  719","line":"       *  @param __k    Key to use for finding a possibly existing pair in"},
{"lineNum":"  720","line":"       *                the map."},
{"lineNum":"  721","line":"       *  @param __args  Arguments used to generate the .second for a new pair"},
{"lineNum":"  722","line":"       *                instance."},
{"lineNum":"  723","line":"       *  @return An iterator that points to the element with key of the"},
{"lineNum":"  724","line":"       *          std::pair built from @a __args (may or may not be that"},
{"lineNum":"  725","line":"       *          std::pair)."},
{"lineNum":"  726","line":"       *"},
{"lineNum":"  727","line":"       *  This function is not concerned about whether the insertion took place,"},
{"lineNum":"  728","line":"       *  and thus does not return a boolean like the single-argument"},
{"lineNum":"  729","line":"       *  try_emplace() does. However, if insertion did not take place,"},
{"lineNum":"  730","line":"       *  this function has no effect."},
{"lineNum":"  731","line":"       *  Note that the first parameter is only a hint and can potentially"},
{"lineNum":"  732","line":"       *  improve the performance of the insertion process. A bad hint would"},
{"lineNum":"  733","line":"       *  cause no gains in efficiency."},
{"lineNum":"  734","line":"       *"},
{"lineNum":"  735","line":"       *  See"},
{"lineNum":"  736","line":"       *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints"},
{"lineNum":"  737","line":"       *  for more on @a hinting."},
{"lineNum":"  738","line":"       *"},
{"lineNum":"  739","line":"       *  Insertion requires logarithmic time (if the hint is not taken)."},
{"lineNum":"  740","line":"       */"},
{"lineNum":"  741","line":"      template <typename... _Args>"},
{"lineNum":"  742","line":"\titerator"},
{"lineNum":"  743","line":"\ttry_emplace(const_iterator __hint, const key_type& __k,"},
{"lineNum":"  744","line":"\t\t    _Args&&... __args)"},
{"lineNum":"  745","line":"\t{"},
{"lineNum":"  746","line":"\t  iterator __i;"},
{"lineNum":"  747","line":"\t  auto __true_hint = _M_t._M_get_insert_hint_unique_pos(__hint, __k);"},
{"lineNum":"  748","line":"\t  if (__true_hint.second)"},
{"lineNum":"  749","line":"\t    __i = emplace_hint(iterator(__true_hint.second),"},
{"lineNum":"  750","line":"\t\t\t       std::piecewise_construct,"},
{"lineNum":"  751","line":"\t\t\t       std::forward_as_tuple(__k),"},
{"lineNum":"  752","line":"\t\t\t       std::forward_as_tuple("},
{"lineNum":"  753","line":"\t\t\t\t std::forward<_Args>(__args)...));"},
{"lineNum":"  754","line":"\t  else"},
{"lineNum":"  755","line":"\t    __i = iterator(__true_hint.first);"},
{"lineNum":"  756","line":"\t  return __i;"},
{"lineNum":"  757","line":"\t}"},
{"lineNum":"  758","line":""},
{"lineNum":"  759","line":"      // move-capable overload"},
{"lineNum":"  760","line":"      template <typename... _Args>"},
{"lineNum":"  761","line":"\titerator"},
{"lineNum":"  762","line":"\ttry_emplace(const_iterator __hint, key_type&& __k, _Args&&... __args)"},
{"lineNum":"  763","line":"\t{"},
{"lineNum":"  764","line":"\t  iterator __i;"},
{"lineNum":"  765","line":"\t  auto __true_hint = _M_t._M_get_insert_hint_unique_pos(__hint, __k);"},
{"lineNum":"  766","line":"\t  if (__true_hint.second)"},
{"lineNum":"  767","line":"\t    __i = emplace_hint(iterator(__true_hint.second),"},
{"lineNum":"  768","line":"\t\t\t       std::piecewise_construct,"},
{"lineNum":"  769","line":"\t\t\t       std::forward_as_tuple(std::move(__k)),"},
{"lineNum":"  770","line":"\t\t\t       std::forward_as_tuple("},
{"lineNum":"  771","line":"\t\t\t\t std::forward<_Args>(__args)...));"},
{"lineNum":"  772","line":"\t  else"},
{"lineNum":"  773","line":"\t    __i = iterator(__true_hint.first);"},
{"lineNum":"  774","line":"\t  return __i;"},
{"lineNum":"  775","line":"\t}"},
{"lineNum":"  776","line":"#endif"},
{"lineNum":"  777","line":""},
{"lineNum":"  778","line":"      /**"},
{"lineNum":"  779","line":"       *  @brief Attempts to insert a std::pair into the %map."},
{"lineNum":"  780","line":"       *  @param __x Pair to be inserted (see std::make_pair for easy"},
{"lineNum":"  781","line":"       *\t     creation of pairs)."},
{"lineNum":"  782","line":"       *"},
{"lineNum":"  783","line":"       *  @return  A pair, of which the first element is an iterator that"},
{"lineNum":"  784","line":"       *           points to the possibly inserted pair, and the second is"},
{"lineNum":"  785","line":"       *           a bool that is true if the pair was actually inserted."},
{"lineNum":"  786","line":"       *"},
{"lineNum":"  787","line":"       *  This function attempts to insert a (key, value) %pair into the %map."},
{"lineNum":"  788","line":"       *  A %map relies on unique keys and thus a %pair is only inserted if its"},
{"lineNum":"  789","line":"       *  first element (the key) is not already present in the %map."},
{"lineNum":"  790","line":"       *"},
{"lineNum":"  791","line":"       *  Insertion requires logarithmic time."},
{"lineNum":"  792","line":"       *  @{"},
{"lineNum":"  793","line":"       */"},
{"lineNum":"  794","line":"      std::pair<iterator, bool>"},
{"lineNum":"  795","line":"      insert(const value_type& __x)"},
{"lineNum":"  796","line":"      { return _M_t._M_insert_unique(__x); }"},
{"lineNum":"  797","line":""},
{"lineNum":"  798","line":"#if __cplusplus >= 201103L"},
{"lineNum":"  799","line":"      // _GLIBCXX_RESOLVE_LIB_DEFECTS"},
{"lineNum":"  800","line":"      // 2354. Unnecessary copying when inserting into maps with braced-init"},
{"lineNum":"  801","line":"      std::pair<iterator, bool>"},
{"lineNum":"  802","line":"      insert(value_type&& __x)"},
{"lineNum":"  803","line":"      { return _M_t._M_insert_unique(std::move(__x)); }"},
{"lineNum":"  804","line":""},
{"lineNum":"  805","line":"      template<typename _Pair, typename = typename"},
{"lineNum":"  806","line":"\t       std::enable_if<std::is_constructible<value_type,"},
{"lineNum":"  807","line":"\t\t\t\t\t\t    _Pair&&>::value>::type>"},
{"lineNum":"  808","line":"\tstd::pair<iterator, bool>"},
{"lineNum":"  809","line":"\tinsert(_Pair&& __x)","class":"lineCov","hits":"1","order":"903","possible_hits":"1",},
{"lineNum":"  810","line":"\t{ return _M_t._M_insert_unique(std::forward<_Pair>(__x)); }","class":"linePartCov","hits":"1","order":"904","possible_hits":"2",},
{"lineNum":"  811","line":"#endif"},
{"lineNum":"  812","line":"      // @}"},
{"lineNum":"  813","line":""},
{"lineNum":"  814","line":"#if __cplusplus >= 201103L"},
{"lineNum":"  815","line":"      /**"},
{"lineNum":"  816","line":"       *  @brief Attempts to insert a list of std::pairs into the %map."},
{"lineNum":"  817","line":"       *  @param  __list  A std::initializer_list<value_type> of pairs to be"},
{"lineNum":"  818","line":"       *                  inserted."},
{"lineNum":"  819","line":"       *"},
{"lineNum":"  820","line":"       *  Complexity similar to that of the range constructor."},
{"lineNum":"  821","line":"       */"},
{"lineNum":"  822","line":"      void"},
{"lineNum":"  823","line":"      insert(std::initializer_list<value_type> __list)"},
{"lineNum":"  824","line":"      { insert(__list.begin(), __list.end()); }"},
{"lineNum":"  825","line":"#endif"},
{"lineNum":"  826","line":""},
{"lineNum":"  827","line":"      /**"},
{"lineNum":"  828","line":"       *  @brief Attempts to insert a std::pair into the %map."},
{"lineNum":"  829","line":"       *  @param  __position  An iterator that serves as a hint as to where the"},
{"lineNum":"  830","line":"       *                    pair should be inserted."},
{"lineNum":"  831","line":"       *  @param  __x  Pair to be inserted (see std::make_pair for easy creation"},
{"lineNum":"  832","line":"       *               of pairs)."},
{"lineNum":"  833","line":"       *  @return An iterator that points to the element with key of"},
{"lineNum":"  834","line":"       *           @a __x (may or may not be the %pair passed in)."},
{"lineNum":"  835","line":"       *"},
{"lineNum":"  836","line":""},
{"lineNum":"  837","line":"       *  This function is not concerned about whether the insertion"},
{"lineNum":"  838","line":"       *  took place, and thus does not return a boolean like the"},
{"lineNum":"  839","line":"       *  single-argument insert() does.  Note that the first"},
{"lineNum":"  840","line":"       *  parameter is only a hint and can potentially improve the"},
{"lineNum":"  841","line":"       *  performance of the insertion process.  A bad hint would"},
{"lineNum":"  842","line":"       *  cause no gains in efficiency."},
{"lineNum":"  843","line":"       *"},
{"lineNum":"  844","line":"       *  See"},
{"lineNum":"  845","line":"       *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints"},
{"lineNum":"  846","line":"       *  for more on @a hinting."},
{"lineNum":"  847","line":"       *"},
{"lineNum":"  848","line":"       *  Insertion requires logarithmic time (if the hint is not taken)."},
{"lineNum":"  849","line":"       *  @{"},
{"lineNum":"  850","line":"       */"},
{"lineNum":"  851","line":"      iterator"},
{"lineNum":"  852","line":"#if __cplusplus >= 201103L"},
{"lineNum":"  853","line":"      insert(const_iterator __position, const value_type& __x)"},
{"lineNum":"  854","line":"#else"},
{"lineNum":"  855","line":"      insert(iterator __position, const value_type& __x)"},
{"lineNum":"  856","line":"#endif"},
{"lineNum":"  857","line":"      { return _M_t._M_insert_unique_(__position, __x); }"},
{"lineNum":"  858","line":""},
{"lineNum":"  859","line":"#if __cplusplus >= 201103L"},
{"lineNum":"  860","line":"      // _GLIBCXX_RESOLVE_LIB_DEFECTS"},
{"lineNum":"  861","line":"      // 2354. Unnecessary copying when inserting into maps with braced-init"},
{"lineNum":"  862","line":"      iterator"},
{"lineNum":"  863","line":"      insert(const_iterator __position, value_type&& __x)"},
{"lineNum":"  864","line":"      { return _M_t._M_insert_unique_(__position, std::move(__x)); }"},
{"lineNum":"  865","line":""},
{"lineNum":"  866","line":"      template<typename _Pair, typename = typename"},
{"lineNum":"  867","line":"\t       std::enable_if<std::is_constructible<value_type,"},
{"lineNum":"  868","line":"\t\t\t\t\t\t    _Pair&&>::value>::type>"},
{"lineNum":"  869","line":"\titerator"},
{"lineNum":"  870","line":"\tinsert(const_iterator __position, _Pair&& __x)"},
{"lineNum":"  871","line":"\t{ return _M_t._M_insert_unique_(__position,"},
{"lineNum":"  872","line":"\t\t\t\t\tstd::forward<_Pair>(__x)); }"},
{"lineNum":"  873","line":"#endif"},
{"lineNum":"  874","line":"      // @}"},
{"lineNum":"  875","line":""},
{"lineNum":"  876","line":"      /**"},
{"lineNum":"  877","line":"       *  @brief Template function that attempts to insert a range of elements."},
{"lineNum":"  878","line":"       *  @param  __first  Iterator pointing to the start of the range to be"},
{"lineNum":"  879","line":"       *                   inserted."},
{"lineNum":"  880","line":"       *  @param  __last  Iterator pointing to the end of the range."},
{"lineNum":"  881","line":"       *"},
{"lineNum":"  882","line":"       *  Complexity similar to that of the range constructor."},
{"lineNum":"  883","line":"       */"},
{"lineNum":"  884","line":"      template<typename _InputIterator>"},
{"lineNum":"  885","line":"\tvoid"},
{"lineNum":"  886","line":"\tinsert(_InputIterator __first, _InputIterator __last)"},
{"lineNum":"  887","line":"\t{ _M_t._M_insert_unique(__first, __last); }"},
{"lineNum":"  888","line":""},
{"lineNum":"  889","line":"#if __cplusplus > 201402L"},
{"lineNum":"  890","line":"#define __cpp_lib_map_insertion 201411"},
{"lineNum":"  891","line":"      /**"},
{"lineNum":"  892","line":"       *  @brief Attempts to insert or assign a std::pair into the %map."},
{"lineNum":"  893","line":"       *  @param __k    Key to use for finding a possibly existing pair in"},
{"lineNum":"  894","line":"       *                the map."},
{"lineNum":"  895","line":"       *  @param __obj  Argument used to generate the .second for a pair"},
{"lineNum":"  896","line":"       *                instance."},
{"lineNum":"  897","line":"       *"},
{"lineNum":"  898","line":"       *  @return  A pair, of which the first element is an iterator that"},
{"lineNum":"  899","line":"       *           points to the possibly inserted pair, and the second is"},
{"lineNum":"  900","line":"       *           a bool that is true if the pair was actually inserted."},
{"lineNum":"  901","line":"       *"},
{"lineNum":"  902","line":"       *  This function attempts to insert a (key, value) %pair into the %map."},
{"lineNum":"  903","line":"       *  A %map relies on unique keys and thus a %pair is only inserted if its"},
{"lineNum":"  904","line":"       *  first element (the key) is not already present in the %map."},
{"lineNum":"  905","line":"       *  If the %pair was already in the %map, the .second of the %pair"},
{"lineNum":"  906","line":"       *  is assigned from __obj."},
{"lineNum":"  907","line":"       *"},
{"lineNum":"  908","line":"       *  Insertion requires logarithmic time."},
{"lineNum":"  909","line":"       */"},
{"lineNum":"  910","line":"      template <typename _Obj>"},
{"lineNum":"  911","line":"\tpair<iterator, bool>"},
{"lineNum":"  912","line":"\tinsert_or_assign(const key_type& __k, _Obj&& __obj)"},
{"lineNum":"  913","line":"\t{"},
{"lineNum":"  914","line":"\t  iterator __i = lower_bound(__k);"},
{"lineNum":"  915","line":"\t  if (__i == end() || key_comp()(__k, (*__i).first))"},
{"lineNum":"  916","line":"\t    {"},
{"lineNum":"  917","line":"\t      __i = emplace_hint(__i, std::piecewise_construct,"},
{"lineNum":"  918","line":"\t\t\t\t std::forward_as_tuple(__k),"},
{"lineNum":"  919","line":"\t\t\t\t std::forward_as_tuple("},
{"lineNum":"  920","line":"\t\t\t\t   std::forward<_Obj>(__obj)));"},
{"lineNum":"  921","line":"\t      return {__i, true};"},
{"lineNum":"  922","line":"\t    }"},
{"lineNum":"  923","line":"\t  (*__i).second = std::forward<_Obj>(__obj);"},
{"lineNum":"  924","line":"\t  return {__i, false};"},
{"lineNum":"  925","line":"\t}"},
{"lineNum":"  926","line":""},
{"lineNum":"  927","line":"      // move-capable overload"},
{"lineNum":"  928","line":"      template <typename _Obj>"},
{"lineNum":"  929","line":"\tpair<iterator, bool>"},
{"lineNum":"  930","line":"\tinsert_or_assign(key_type&& __k, _Obj&& __obj)"},
{"lineNum":"  931","line":"\t{"},
{"lineNum":"  932","line":"\t  iterator __i = lower_bound(__k);"},
{"lineNum":"  933","line":"\t  if (__i == end() || key_comp()(__k, (*__i).first))"},
{"lineNum":"  934","line":"\t    {"},
{"lineNum":"  935","line":"\t      __i = emplace_hint(__i, std::piecewise_construct,"},
{"lineNum":"  936","line":"\t\t\t\t std::forward_as_tuple(std::move(__k)),"},
{"lineNum":"  937","line":"\t\t\t\t std::forward_as_tuple("},
{"lineNum":"  938","line":"\t\t\t\t   std::forward<_Obj>(__obj)));"},
{"lineNum":"  939","line":"\t      return {__i, true};"},
{"lineNum":"  940","line":"\t    }"},
{"lineNum":"  941","line":"\t  (*__i).second = std::forward<_Obj>(__obj);"},
{"lineNum":"  942","line":"\t  return {__i, false};"},
{"lineNum":"  943","line":"\t}"},
{"lineNum":"  944","line":""},
{"lineNum":"  945","line":"      /**"},
{"lineNum":"  946","line":"       *  @brief Attempts to insert or assign a std::pair into the %map."},
{"lineNum":"  947","line":"       *  @param  __hint  An iterator that serves as a hint as to where the"},
{"lineNum":"  948","line":"       *                  pair should be inserted."},
{"lineNum":"  949","line":"       *  @param __k    Key to use for finding a possibly existing pair in"},
{"lineNum":"  950","line":"       *                the map."},
{"lineNum":"  951","line":"       *  @param __obj  Argument used to generate the .second for a pair"},
{"lineNum":"  952","line":"       *                instance."},
{"lineNum":"  953","line":"       *"},
{"lineNum":"  954","line":"       *  @return An iterator that points to the element with key of"},
{"lineNum":"  955","line":"       *           @a __x (may or may not be the %pair passed in)."},
{"lineNum":"  956","line":"       *"},
{"lineNum":"  957","line":"       *  This function attempts to insert a (key, value) %pair into the %map."},
{"lineNum":"  958","line":"       *  A %map relies on unique keys and thus a %pair is only inserted if its"},
{"lineNum":"  959","line":"       *  first element (the key) is not already present in the %map."},
{"lineNum":"  960","line":"       *  If the %pair was already in the %map, the .second of the %pair"},
{"lineNum":"  961","line":"       *  is assigned from __obj."},
{"lineNum":"  962","line":"       *"},
{"lineNum":"  963","line":"       *  Insertion requires logarithmic time."},
{"lineNum":"  964","line":"       */"},
{"lineNum":"  965","line":"      template <typename _Obj>"},
{"lineNum":"  966","line":"\titerator"},
{"lineNum":"  967","line":"\tinsert_or_assign(const_iterator __hint,"},
{"lineNum":"  968","line":"\t\t\t const key_type& __k, _Obj&& __obj)"},
{"lineNum":"  969","line":"\t{"},
{"lineNum":"  970","line":"\t  iterator __i;"},
{"lineNum":"  971","line":"\t  auto __true_hint = _M_t._M_get_insert_hint_unique_pos(__hint, __k);"},
{"lineNum":"  972","line":"\t  if (__true_hint.second)"},
{"lineNum":"  973","line":"\t    {"},
{"lineNum":"  974","line":"\t      return emplace_hint(iterator(__true_hint.second),"},
{"lineNum":"  975","line":"\t\t\t\t  std::piecewise_construct,"},
{"lineNum":"  976","line":"\t\t\t\t  std::forward_as_tuple(__k),"},
{"lineNum":"  977","line":"\t\t\t\t  std::forward_as_tuple("},
{"lineNum":"  978","line":"\t\t\t\t    std::forward<_Obj>(__obj)));"},
{"lineNum":"  979","line":"\t    }"},
{"lineNum":"  980","line":"\t  __i = iterator(__true_hint.first);"},
{"lineNum":"  981","line":"\t  (*__i).second = std::forward<_Obj>(__obj);"},
{"lineNum":"  982","line":"\t  return __i;"},
{"lineNum":"  983","line":"\t}"},
{"lineNum":"  984","line":""},
{"lineNum":"  985","line":"      // move-capable overload"},
{"lineNum":"  986","line":"      template <typename _Obj>"},
{"lineNum":"  987","line":"\titerator"},
{"lineNum":"  988","line":"\tinsert_or_assign(const_iterator __hint, key_type&& __k, _Obj&& __obj)"},
{"lineNum":"  989","line":"\t{"},
{"lineNum":"  990","line":"\t  iterator __i;"},
{"lineNum":"  991","line":"\t  auto __true_hint = _M_t._M_get_insert_hint_unique_pos(__hint, __k);"},
{"lineNum":"  992","line":"\t  if (__true_hint.second)"},
{"lineNum":"  993","line":"\t    {"},
{"lineNum":"  994","line":"\t      return emplace_hint(iterator(__true_hint.second),"},
{"lineNum":"  995","line":"\t\t\t\t  std::piecewise_construct,"},
{"lineNum":"  996","line":"\t\t\t\t  std::forward_as_tuple(std::move(__k)),"},
{"lineNum":"  997","line":"\t\t\t\t  std::forward_as_tuple("},
{"lineNum":"  998","line":"\t\t\t\t    std::forward<_Obj>(__obj)));"},
{"lineNum":"  999","line":"\t    }"},
{"lineNum":" 1000","line":"\t  __i = iterator(__true_hint.first);"},
{"lineNum":" 1001","line":"\t  (*__i).second = std::forward<_Obj>(__obj);"},
{"lineNum":" 1002","line":"\t  return __i;"},
{"lineNum":" 1003","line":"\t}"},
{"lineNum":" 1004","line":"#endif"},
{"lineNum":" 1005","line":""},
{"lineNum":" 1006","line":"#if __cplusplus >= 201103L"},
{"lineNum":" 1007","line":"      // _GLIBCXX_RESOLVE_LIB_DEFECTS"},
{"lineNum":" 1008","line":"      // DR 130. Associative erase should return an iterator."},
{"lineNum":" 1009","line":"      /**"},
{"lineNum":" 1010","line":"       *  @brief Erases an element from a %map."},
{"lineNum":" 1011","line":"       *  @param  __position  An iterator pointing to the element to be erased."},
{"lineNum":" 1012","line":"       *  @return An iterator pointing to the element immediately following"},
{"lineNum":" 1013","line":"       *          @a position prior to the element being erased. If no such"},
{"lineNum":" 1014","line":"       *          element exists, end() is returned."},
{"lineNum":" 1015","line":"       *"},
{"lineNum":" 1016","line":"       *  This function erases an element, pointed to by the given"},
{"lineNum":" 1017","line":"       *  iterator, from a %map.  Note that this function only erases"},
{"lineNum":" 1018","line":"       *  the element, and that if the element is itself a pointer,"},
{"lineNum":" 1019","line":"       *  the pointed-to memory is not touched in any way.  Managing"},
{"lineNum":" 1020","line":"       *  the pointer is the user\'s responsibility."},
{"lineNum":" 1021","line":"       *"},
{"lineNum":" 1022","line":"       *  @{"},
{"lineNum":" 1023","line":"       */"},
{"lineNum":" 1024","line":"      iterator"},
{"lineNum":" 1025","line":"      erase(const_iterator __position)"},
{"lineNum":" 1026","line":"      { return _M_t.erase(__position); }"},
{"lineNum":" 1027","line":""},
{"lineNum":" 1028","line":"      // LWG 2059"},
{"lineNum":" 1029","line":"      _GLIBCXX_ABI_TAG_CXX11"},
{"lineNum":" 1030","line":"      iterator"},
{"lineNum":" 1031","line":"      erase(iterator __position)"},
{"lineNum":" 1032","line":"      { return _M_t.erase(__position); }"},
{"lineNum":" 1033","line":"      // @}"},
{"lineNum":" 1034","line":"#else"},
{"lineNum":" 1035","line":"      /**"},
{"lineNum":" 1036","line":"       *  @brief Erases an element from a %map."},
{"lineNum":" 1037","line":"       *  @param  __position  An iterator pointing to the element to be erased."},
{"lineNum":" 1038","line":"       *"},
{"lineNum":" 1039","line":"       *  This function erases an element, pointed to by the given"},
{"lineNum":" 1040","line":"       *  iterator, from a %map.  Note that this function only erases"},
{"lineNum":" 1041","line":"       *  the element, and that if the element is itself a pointer,"},
{"lineNum":" 1042","line":"       *  the pointed-to memory is not touched in any way.  Managing"},
{"lineNum":" 1043","line":"       *  the pointer is the user\'s responsibility."},
{"lineNum":" 1044","line":"       */"},
{"lineNum":" 1045","line":"      void"},
{"lineNum":" 1046","line":"      erase(iterator __position)"},
{"lineNum":" 1047","line":"      { _M_t.erase(__position); }"},
{"lineNum":" 1048","line":"#endif"},
{"lineNum":" 1049","line":""},
{"lineNum":" 1050","line":"      /**"},
{"lineNum":" 1051","line":"       *  @brief Erases elements according to the provided key."},
{"lineNum":" 1052","line":"       *  @param  __x  Key of element to be erased."},
{"lineNum":" 1053","line":"       *  @return  The number of elements erased."},
{"lineNum":" 1054","line":"       *"},
{"lineNum":" 1055","line":"       *  This function erases all the elements located by the given key from"},
{"lineNum":" 1056","line":"       *  a %map."},
{"lineNum":" 1057","line":"       *  Note that this function only erases the element, and that if"},
{"lineNum":" 1058","line":"       *  the element is itself a pointer, the pointed-to memory is not touched"},
{"lineNum":" 1059","line":"       *  in any way.  Managing the pointer is the user\'s responsibility."},
{"lineNum":" 1060","line":"       */"},
{"lineNum":" 1061","line":"      size_type"},
{"lineNum":" 1062","line":"      erase(const key_type& __x)"},
{"lineNum":" 1063","line":"      { return _M_t.erase(__x); }"},
{"lineNum":" 1064","line":""},
{"lineNum":" 1065","line":"#if __cplusplus >= 201103L"},
{"lineNum":" 1066","line":"      // _GLIBCXX_RESOLVE_LIB_DEFECTS"},
{"lineNum":" 1067","line":"      // DR 130. Associative erase should return an iterator."},
{"lineNum":" 1068","line":"      /**"},
{"lineNum":" 1069","line":"       *  @brief Erases a [first,last) range of elements from a %map."},
{"lineNum":" 1070","line":"       *  @param  __first  Iterator pointing to the start of the range to be"},
{"lineNum":" 1071","line":"       *                   erased."},
{"lineNum":" 1072","line":"       *  @param __last Iterator pointing to the end of the range to"},
{"lineNum":" 1073","line":"       *                be erased."},
{"lineNum":" 1074","line":"       *  @return The iterator @a __last."},
{"lineNum":" 1075","line":"       *"},
{"lineNum":" 1076","line":"       *  This function erases a sequence of elements from a %map."},
{"lineNum":" 1077","line":"       *  Note that this function only erases the element, and that if"},
{"lineNum":" 1078","line":"       *  the element is itself a pointer, the pointed-to memory is not touched"},
{"lineNum":" 1079","line":"       *  in any way.  Managing the pointer is the user\'s responsibility."},
{"lineNum":" 1080","line":"       */"},
{"lineNum":" 1081","line":"      iterator"},
{"lineNum":" 1082","line":"      erase(const_iterator __first, const_iterator __last)"},
{"lineNum":" 1083","line":"      { return _M_t.erase(__first, __last); }"},
{"lineNum":" 1084","line":"#else"},
{"lineNum":" 1085","line":"      /**"},
{"lineNum":" 1086","line":"       *  @brief Erases a [__first,__last) range of elements from a %map."},
{"lineNum":" 1087","line":"       *  @param  __first  Iterator pointing to the start of the range to be"},
{"lineNum":" 1088","line":"       *                   erased."},
{"lineNum":" 1089","line":"       *  @param __last Iterator pointing to the end of the range to"},
{"lineNum":" 1090","line":"       *                be erased."},
{"lineNum":" 1091","line":"       *"},
{"lineNum":" 1092","line":"       *  This function erases a sequence of elements from a %map."},
{"lineNum":" 1093","line":"       *  Note that this function only erases the element, and that if"},
{"lineNum":" 1094","line":"       *  the element is itself a pointer, the pointed-to memory is not touched"},
{"lineNum":" 1095","line":"       *  in any way.  Managing the pointer is the user\'s responsibility."},
{"lineNum":" 1096","line":"       */"},
{"lineNum":" 1097","line":"      void"},
{"lineNum":" 1098","line":"      erase(iterator __first, iterator __last)"},
{"lineNum":" 1099","line":"      { _M_t.erase(__first, __last); }"},
{"lineNum":" 1100","line":"#endif"},
{"lineNum":" 1101","line":""},
{"lineNum":" 1102","line":"      /**"},
{"lineNum":" 1103","line":"       *  @brief  Swaps data with another %map."},
{"lineNum":" 1104","line":"       *  @param  __x  A %map of the same element and allocator types."},
{"lineNum":" 1105","line":"       *"},
{"lineNum":" 1106","line":"       *  This exchanges the elements between two maps in constant"},
{"lineNum":" 1107","line":"       *  time.  (It is only swapping a pointer, an integer, and an"},
{"lineNum":" 1108","line":"       *  instance of the @c Compare type (which itself is often"},
{"lineNum":" 1109","line":"       *  stateless and empty), so it should be quite fast.)  Note"},
{"lineNum":" 1110","line":"       *  that the global std::swap() function is specialized such"},
{"lineNum":" 1111","line":"       *  that std::swap(m1,m2) will feed to this function."},
{"lineNum":" 1112","line":"       *"},
{"lineNum":" 1113","line":"       *  Whether the allocators are swapped depends on the allocator traits."},
{"lineNum":" 1114","line":"       */"},
{"lineNum":" 1115","line":"      void"},
{"lineNum":" 1116","line":"      swap(map& __x)"},
{"lineNum":" 1117","line":"      _GLIBCXX_NOEXCEPT_IF(__is_nothrow_swappable<_Compare>::value)"},
{"lineNum":" 1118","line":"      { _M_t.swap(__x._M_t); }"},
{"lineNum":" 1119","line":""},
{"lineNum":" 1120","line":"      /**"},
{"lineNum":" 1121","line":"       *  Erases all elements in a %map.  Note that this function only"},
{"lineNum":" 1122","line":"       *  erases the elements, and that if the elements themselves are"},
{"lineNum":" 1123","line":"       *  pointers, the pointed-to memory is not touched in any way."},
{"lineNum":" 1124","line":"       *  Managing the pointer is the user\'s responsibility."},
{"lineNum":" 1125","line":"       */"},
{"lineNum":" 1126","line":"      void"},
{"lineNum":" 1127","line":"      clear() _GLIBCXX_NOEXCEPT"},
{"lineNum":" 1128","line":"      { _M_t.clear(); }"},
{"lineNum":" 1129","line":""},
{"lineNum":" 1130","line":"      // observers"},
{"lineNum":" 1131","line":"      /**"},
{"lineNum":" 1132","line":"       *  Returns the key comparison object out of which the %map was"},
{"lineNum":" 1133","line":"       *  constructed."},
{"lineNum":" 1134","line":"       */"},
{"lineNum":" 1135","line":"      key_compare"},
{"lineNum":" 1136","line":"      key_comp() const"},
{"lineNum":" 1137","line":"      { return _M_t.key_comp(); }"},
{"lineNum":" 1138","line":""},
{"lineNum":" 1139","line":"      /**"},
{"lineNum":" 1140","line":"       *  Returns a value comparison object, built from the key comparison"},
{"lineNum":" 1141","line":"       *  object out of which the %map was constructed."},
{"lineNum":" 1142","line":"       */"},
{"lineNum":" 1143","line":"      value_compare"},
{"lineNum":" 1144","line":"      value_comp() const"},
{"lineNum":" 1145","line":"      { return value_compare(_M_t.key_comp()); }"},
{"lineNum":" 1146","line":""},
{"lineNum":" 1147","line":"      // [23.3.1.3] map operations"},
{"lineNum":" 1148","line":""},
{"lineNum":" 1149","line":"      //@{"},
{"lineNum":" 1150","line":"      /**"},
{"lineNum":" 1151","line":"       *  @brief Tries to locate an element in a %map."},
{"lineNum":" 1152","line":"       *  @param  __x  Key of (key, value) %pair to be located."},
{"lineNum":" 1153","line":"       *  @return  Iterator pointing to sought-after element, or end() if not"},
{"lineNum":" 1154","line":"       *           found."},
{"lineNum":" 1155","line":"       *"},
{"lineNum":" 1156","line":"       *  This function takes a key and tries to locate the element with which"},
{"lineNum":" 1157","line":"       *  the key matches.  If successful the function returns an iterator"},
{"lineNum":" 1158","line":"       *  pointing to the sought after %pair.  If unsuccessful it returns the"},
{"lineNum":" 1159","line":"       *  past-the-end ( @c end() ) iterator."},
{"lineNum":" 1160","line":"       */"},
{"lineNum":" 1161","line":""},
{"lineNum":" 1162","line":"      iterator"},
{"lineNum":" 1163","line":"      find(const key_type& __x)","class":"lineCov","hits":"1","order":"881","possible_hits":"1",},
{"lineNum":" 1164","line":"      { return _M_t.find(__x); }","class":"linePartCov","hits":"1","order":"882","possible_hits":"2",},
{"lineNum":" 1165","line":""},
{"lineNum":" 1166","line":"#if __cplusplus > 201103L"},
{"lineNum":" 1167","line":"      template<typename _Kt>"},
{"lineNum":" 1168","line":"\tauto"},
{"lineNum":" 1169","line":"\tfind(const _Kt& __x) -> decltype(_M_t._M_find_tr(__x))"},
{"lineNum":" 1170","line":"\t{ return _M_t._M_find_tr(__x); }"},
{"lineNum":" 1171","line":"#endif"},
{"lineNum":" 1172","line":"      //@}"},
{"lineNum":" 1173","line":""},
{"lineNum":" 1174","line":"      //@{"},
{"lineNum":" 1175","line":"      /**"},
{"lineNum":" 1176","line":"       *  @brief Tries to locate an element in a %map."},
{"lineNum":" 1177","line":"       *  @param  __x  Key of (key, value) %pair to be located."},
{"lineNum":" 1178","line":"       *  @return  Read-only (constant) iterator pointing to sought-after"},
{"lineNum":" 1179","line":"       *           element, or end() if not found."},
{"lineNum":" 1180","line":"       *"},
{"lineNum":" 1181","line":"       *  This function takes a key and tries to locate the element with which"},
{"lineNum":" 1182","line":"       *  the key matches.  If successful the function returns a constant"},
{"lineNum":" 1183","line":"       *  iterator pointing to the sought after %pair. If unsuccessful it"},
{"lineNum":" 1184","line":"       *  returns the past-the-end ( @c end() ) iterator."},
{"lineNum":" 1185","line":"       */"},
{"lineNum":" 1186","line":""},
{"lineNum":" 1187","line":"      const_iterator"},
{"lineNum":" 1188","line":"      find(const key_type& __x) const"},
{"lineNum":" 1189","line":"      { return _M_t.find(__x); }"},
{"lineNum":" 1190","line":""},
{"lineNum":" 1191","line":"#if __cplusplus > 201103L"},
{"lineNum":" 1192","line":"      template<typename _Kt>"},
{"lineNum":" 1193","line":"\tauto"},
{"lineNum":" 1194","line":"\tfind(const _Kt& __x) const -> decltype(_M_t._M_find_tr(__x))"},
{"lineNum":" 1195","line":"\t{ return _M_t._M_find_tr(__x); }"},
{"lineNum":" 1196","line":"#endif"},
{"lineNum":" 1197","line":"      //@}"},
{"lineNum":" 1198","line":""},
{"lineNum":" 1199","line":"      //@{"},
{"lineNum":" 1200","line":"      /**"},
{"lineNum":" 1201","line":"       *  @brief  Finds the number of elements with given key."},
{"lineNum":" 1202","line":"       *  @param  __x  Key of (key, value) pairs to be located."},
{"lineNum":" 1203","line":"       *  @return  Number of elements with specified key."},
{"lineNum":" 1204","line":"       *"},
{"lineNum":" 1205","line":"       *  This function only makes sense for multimaps; for map the result will"},
{"lineNum":" 1206","line":"       *  either be 0 (not present) or 1 (present)."},
{"lineNum":" 1207","line":"       */"},
{"lineNum":" 1208","line":"      size_type"},
{"lineNum":" 1209","line":"      count(const key_type& __x) const"},
{"lineNum":" 1210","line":"      { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }"},
{"lineNum":" 1211","line":""},
{"lineNum":" 1212","line":"#if __cplusplus > 201103L"},
{"lineNum":" 1213","line":"      template<typename _Kt>"},
{"lineNum":" 1214","line":"\tauto"},
{"lineNum":" 1215","line":"\tcount(const _Kt& __x) const -> decltype(_M_t._M_count_tr(__x))"},
{"lineNum":" 1216","line":"\t{ return _M_t._M_count_tr(__x); }"},
{"lineNum":" 1217","line":"#endif"},
{"lineNum":" 1218","line":"      //@}"},
{"lineNum":" 1219","line":""},
{"lineNum":" 1220","line":"      //@{"},
{"lineNum":" 1221","line":"      /**"},
{"lineNum":" 1222","line":"       *  @brief Finds the beginning of a subsequence matching given key."},
{"lineNum":" 1223","line":"       *  @param  __x  Key of (key, value) pair to be located."},
{"lineNum":" 1224","line":"       *  @return  Iterator pointing to first element equal to or greater"},
{"lineNum":" 1225","line":"       *           than key, or end()."},
{"lineNum":" 1226","line":"       *"},
{"lineNum":" 1227","line":"       *  This function returns the first element of a subsequence of elements"},
{"lineNum":" 1228","line":"       *  that matches the given key.  If unsuccessful it returns an iterator"},
{"lineNum":" 1229","line":"       *  pointing to the first element that has a greater value than given key"},
{"lineNum":" 1230","line":"       *  or end() if no such element exists."},
{"lineNum":" 1231","line":"       */"},
{"lineNum":" 1232","line":"      iterator"},
{"lineNum":" 1233","line":"      lower_bound(const key_type& __x)"},
{"lineNum":" 1234","line":"      { return _M_t.lower_bound(__x); }"},
{"lineNum":" 1235","line":""},
{"lineNum":" 1236","line":"#if __cplusplus > 201103L"},
{"lineNum":" 1237","line":"      template<typename _Kt>"},
{"lineNum":" 1238","line":"\tauto"},
{"lineNum":" 1239","line":"\tlower_bound(const _Kt& __x)"},
{"lineNum":" 1240","line":"\t-> decltype(iterator(_M_t._M_lower_bound_tr(__x)))"},
{"lineNum":" 1241","line":"\t{ return iterator(_M_t._M_lower_bound_tr(__x)); }"},
{"lineNum":" 1242","line":"#endif"},
{"lineNum":" 1243","line":"      //@}"},
{"lineNum":" 1244","line":""},
{"lineNum":" 1245","line":"      //@{"},
{"lineNum":" 1246","line":"      /**"},
{"lineNum":" 1247","line":"       *  @brief Finds the beginning of a subsequence matching given key."},
{"lineNum":" 1248","line":"       *  @param  __x  Key of (key, value) pair to be located."},
{"lineNum":" 1249","line":"       *  @return  Read-only (constant) iterator pointing to first element"},
{"lineNum":" 1250","line":"       *           equal to or greater than key, or end()."},
{"lineNum":" 1251","line":"       *"},
{"lineNum":" 1252","line":"       *  This function returns the first element of a subsequence of elements"},
{"lineNum":" 1253","line":"       *  that matches the given key.  If unsuccessful it returns an iterator"},
{"lineNum":" 1254","line":"       *  pointing to the first element that has a greater value than given key"},
{"lineNum":" 1255","line":"       *  or end() if no such element exists."},
{"lineNum":" 1256","line":"       */"},
{"lineNum":" 1257","line":"      const_iterator"},
{"lineNum":" 1258","line":"      lower_bound(const key_type& __x) const"},
{"lineNum":" 1259","line":"      { return _M_t.lower_bound(__x); }"},
{"lineNum":" 1260","line":""},
{"lineNum":" 1261","line":"#if __cplusplus > 201103L"},
{"lineNum":" 1262","line":"      template<typename _Kt>"},
{"lineNum":" 1263","line":"\tauto"},
{"lineNum":" 1264","line":"\tlower_bound(const _Kt& __x) const"},
{"lineNum":" 1265","line":"\t-> decltype(const_iterator(_M_t._M_lower_bound_tr(__x)))"},
{"lineNum":" 1266","line":"\t{ return const_iterator(_M_t._M_lower_bound_tr(__x)); }"},
{"lineNum":" 1267","line":"#endif"},
{"lineNum":" 1268","line":"      //@}"},
{"lineNum":" 1269","line":""},
{"lineNum":" 1270","line":"      //@{"},
{"lineNum":" 1271","line":"      /**"},
{"lineNum":" 1272","line":"       *  @brief Finds the end of a subsequence matching given key."},
{"lineNum":" 1273","line":"       *  @param  __x  Key of (key, value) pair to be located."},
{"lineNum":" 1274","line":"       *  @return Iterator pointing to the first element"},
{"lineNum":" 1275","line":"       *          greater than key, or end()."},
{"lineNum":" 1276","line":"       */"},
{"lineNum":" 1277","line":"      iterator"},
{"lineNum":" 1278","line":"      upper_bound(const key_type& __x)"},
{"lineNum":" 1279","line":"      { return _M_t.upper_bound(__x); }"},
{"lineNum":" 1280","line":""},
{"lineNum":" 1281","line":"#if __cplusplus > 201103L"},
{"lineNum":" 1282","line":"      template<typename _Kt>"},
{"lineNum":" 1283","line":"\tauto"},
{"lineNum":" 1284","line":"\tupper_bound(const _Kt& __x)"},
{"lineNum":" 1285","line":"\t-> decltype(iterator(_M_t._M_upper_bound_tr(__x)))"},
{"lineNum":" 1286","line":"\t{ return iterator(_M_t._M_upper_bound_tr(__x)); }"},
{"lineNum":" 1287","line":"#endif"},
{"lineNum":" 1288","line":"      //@}"},
{"lineNum":" 1289","line":""},
{"lineNum":" 1290","line":"      //@{"},
{"lineNum":" 1291","line":"      /**"},
{"lineNum":" 1292","line":"       *  @brief Finds the end of a subsequence matching given key."},
{"lineNum":" 1293","line":"       *  @param  __x  Key of (key, value) pair to be located."},
{"lineNum":" 1294","line":"       *  @return  Read-only (constant) iterator pointing to first iterator"},
{"lineNum":" 1295","line":"       *           greater than key, or end()."},
{"lineNum":" 1296","line":"       */"},
{"lineNum":" 1297","line":"      const_iterator"},
{"lineNum":" 1298","line":"      upper_bound(const key_type& __x) const"},
{"lineNum":" 1299","line":"      { return _M_t.upper_bound(__x); }"},
{"lineNum":" 1300","line":""},
{"lineNum":" 1301","line":"#if __cplusplus > 201103L"},
{"lineNum":" 1302","line":"      template<typename _Kt>"},
{"lineNum":" 1303","line":"\tauto"},
{"lineNum":" 1304","line":"\tupper_bound(const _Kt& __x) const"},
{"lineNum":" 1305","line":"\t-> decltype(const_iterator(_M_t._M_upper_bound_tr(__x)))"},
{"lineNum":" 1306","line":"\t{ return const_iterator(_M_t._M_upper_bound_tr(__x)); }"},
{"lineNum":" 1307","line":"#endif"},
{"lineNum":" 1308","line":"      //@}"},
{"lineNum":" 1309","line":""},
{"lineNum":" 1310","line":"      //@{"},
{"lineNum":" 1311","line":"      /**"},
{"lineNum":" 1312","line":"       *  @brief Finds a subsequence matching given key."},
{"lineNum":" 1313","line":"       *  @param  __x  Key of (key, value) pairs to be located."},
{"lineNum":" 1314","line":"       *  @return  Pair of iterators that possibly points to the subsequence"},
{"lineNum":" 1315","line":"       *           matching given key."},
{"lineNum":" 1316","line":"       *"},
{"lineNum":" 1317","line":"       *  This function is equivalent to"},
{"lineNum":" 1318","line":"       *  @code"},
{"lineNum":" 1319","line":"       *    std::make_pair(c.lower_bound(val),"},
{"lineNum":" 1320","line":"       *                   c.upper_bound(val))"},
{"lineNum":" 1321","line":"       *  @endcode"},
{"lineNum":" 1322","line":"       *  (but is faster than making the calls separately)."},
{"lineNum":" 1323","line":"       *"},
{"lineNum":" 1324","line":"       *  This function probably only makes sense for multimaps."},
{"lineNum":" 1325","line":"       */"},
{"lineNum":" 1326","line":"      std::pair<iterator, iterator>"},
{"lineNum":" 1327","line":"      equal_range(const key_type& __x)"},
{"lineNum":" 1328","line":"      { return _M_t.equal_range(__x); }"},
{"lineNum":" 1329","line":""},
{"lineNum":" 1330","line":"#if __cplusplus > 201103L"},
{"lineNum":" 1331","line":"      template<typename _Kt>"},
{"lineNum":" 1332","line":"\tauto"},
{"lineNum":" 1333","line":"\tequal_range(const _Kt& __x)"},
{"lineNum":" 1334","line":"\t-> decltype(pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)))"},
{"lineNum":" 1335","line":"\t{ return pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)); }"},
{"lineNum":" 1336","line":"#endif"},
{"lineNum":" 1337","line":"      //@}"},
{"lineNum":" 1338","line":""},
{"lineNum":" 1339","line":"      //@{"},
{"lineNum":" 1340","line":"      /**"},
{"lineNum":" 1341","line":"       *  @brief Finds a subsequence matching given key."},
{"lineNum":" 1342","line":"       *  @param  __x  Key of (key, value) pairs to be located."},
{"lineNum":" 1343","line":"       *  @return  Pair of read-only (constant) iterators that possibly points"},
{"lineNum":" 1344","line":"       *           to the subsequence matching given key."},
{"lineNum":" 1345","line":"       *"},
{"lineNum":" 1346","line":"       *  This function is equivalent to"},
{"lineNum":" 1347","line":"       *  @code"},
{"lineNum":" 1348","line":"       *    std::make_pair(c.lower_bound(val),"},
{"lineNum":" 1349","line":"       *                   c.upper_bound(val))"},
{"lineNum":" 1350","line":"       *  @endcode"},
{"lineNum":" 1351","line":"       *  (but is faster than making the calls separately)."},
{"lineNum":" 1352","line":"       *"},
{"lineNum":" 1353","line":"       *  This function probably only makes sense for multimaps."},
{"lineNum":" 1354","line":"       */"},
{"lineNum":" 1355","line":"      std::pair<const_iterator, const_iterator>"},
{"lineNum":" 1356","line":"      equal_range(const key_type& __x) const"},
{"lineNum":" 1357","line":"      { return _M_t.equal_range(__x); }"},
{"lineNum":" 1358","line":""},
{"lineNum":" 1359","line":"#if __cplusplus > 201103L"},
{"lineNum":" 1360","line":"      template<typename _Kt>"},
{"lineNum":" 1361","line":"\tauto"},
{"lineNum":" 1362","line":"\tequal_range(const _Kt& __x) const"},
{"lineNum":" 1363","line":"\t-> decltype(pair<const_iterator, const_iterator>("},
{"lineNum":" 1364","line":"\t      _M_t._M_equal_range_tr(__x)))"},
{"lineNum":" 1365","line":"\t{"},
{"lineNum":" 1366","line":"\t  return pair<const_iterator, const_iterator>("},
{"lineNum":" 1367","line":"\t      _M_t._M_equal_range_tr(__x));"},
{"lineNum":" 1368","line":"\t}"},
{"lineNum":" 1369","line":"#endif"},
{"lineNum":" 1370","line":"      //@}"},
{"lineNum":" 1371","line":""},
{"lineNum":" 1372","line":"      template<typename _K1, typename _T1, typename _C1, typename _A1>"},
{"lineNum":" 1373","line":"\tfriend bool"},
{"lineNum":" 1374","line":"\toperator==(const map<_K1, _T1, _C1, _A1>&,"},
{"lineNum":" 1375","line":"\t\t   const map<_K1, _T1, _C1, _A1>&);"},
{"lineNum":" 1376","line":""},
{"lineNum":" 1377","line":"      template<typename _K1, typename _T1, typename _C1, typename _A1>"},
{"lineNum":" 1378","line":"\tfriend bool"},
{"lineNum":" 1379","line":"\toperator<(const map<_K1, _T1, _C1, _A1>&,"},
{"lineNum":" 1380","line":"\t\t  const map<_K1, _T1, _C1, _A1>&);"},
{"lineNum":" 1381","line":"    };"},
{"lineNum":" 1382","line":""},
{"lineNum":" 1383","line":"  /**"},
{"lineNum":" 1384","line":"   *  @brief  Map equality comparison."},
{"lineNum":" 1385","line":"   *  @param  __x  A %map."},
{"lineNum":" 1386","line":"   *  @param  __y  A %map of the same type as @a x."},
{"lineNum":" 1387","line":"   *  @return  True iff the size and elements of the maps are equal."},
{"lineNum":" 1388","line":"   *"},
{"lineNum":" 1389","line":"   *  This is an equivalence relation.  It is linear in the size of the"},
{"lineNum":" 1390","line":"   *  maps.  Maps are considered equivalent if their sizes are equal,"},
{"lineNum":" 1391","line":"   *  and if corresponding elements compare equal."},
{"lineNum":" 1392","line":"  */"},
{"lineNum":" 1393","line":"  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>"},
{"lineNum":" 1394","line":"    inline bool"},
{"lineNum":" 1395","line":"    operator==(const map<_Key, _Tp, _Compare, _Alloc>& __x,"},
{"lineNum":" 1396","line":"\t       const map<_Key, _Tp, _Compare, _Alloc>& __y)"},
{"lineNum":" 1397","line":"    { return __x._M_t == __y._M_t; }"},
{"lineNum":" 1398","line":""},
{"lineNum":" 1399","line":"  /**"},
{"lineNum":" 1400","line":"   *  @brief  Map ordering relation."},
{"lineNum":" 1401","line":"   *  @param  __x  A %map."},
{"lineNum":" 1402","line":"   *  @param  __y  A %map of the same type as @a x."},
{"lineNum":" 1403","line":"   *  @return  True iff @a x is lexicographically less than @a y."},
{"lineNum":" 1404","line":"   *"},
{"lineNum":" 1405","line":"   *  This is a total ordering relation.  It is linear in the size of the"},
{"lineNum":" 1406","line":"   *  maps.  The elements must be comparable with @c <."},
{"lineNum":" 1407","line":"   *"},
{"lineNum":" 1408","line":"   *  See std::lexicographical_compare() for how the determination is made."},
{"lineNum":" 1409","line":"  */"},
{"lineNum":" 1410","line":"  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>"},
{"lineNum":" 1411","line":"    inline bool"},
{"lineNum":" 1412","line":"    operator<(const map<_Key, _Tp, _Compare, _Alloc>& __x,"},
{"lineNum":" 1413","line":"\t      const map<_Key, _Tp, _Compare, _Alloc>& __y)"},
{"lineNum":" 1414","line":"    { return __x._M_t < __y._M_t; }"},
{"lineNum":" 1415","line":""},
{"lineNum":" 1416","line":"  /// Based on operator=="},
{"lineNum":" 1417","line":"  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>"},
{"lineNum":" 1418","line":"    inline bool"},
{"lineNum":" 1419","line":"    operator!=(const map<_Key, _Tp, _Compare, _Alloc>& __x,"},
{"lineNum":" 1420","line":"\t       const map<_Key, _Tp, _Compare, _Alloc>& __y)"},
{"lineNum":" 1421","line":"    { return !(__x == __y); }"},
{"lineNum":" 1422","line":""},
{"lineNum":" 1423","line":"  /// Based on operator<"},
{"lineNum":" 1424","line":"  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>"},
{"lineNum":" 1425","line":"    inline bool"},
{"lineNum":" 1426","line":"    operator>(const map<_Key, _Tp, _Compare, _Alloc>& __x,"},
{"lineNum":" 1427","line":"\t      const map<_Key, _Tp, _Compare, _Alloc>& __y)"},
{"lineNum":" 1428","line":"    { return __y < __x; }"},
{"lineNum":" 1429","line":""},
{"lineNum":" 1430","line":"  /// Based on operator<"},
{"lineNum":" 1431","line":"  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>"},
{"lineNum":" 1432","line":"    inline bool"},
{"lineNum":" 1433","line":"    operator<=(const map<_Key, _Tp, _Compare, _Alloc>& __x,"},
{"lineNum":" 1434","line":"\t       const map<_Key, _Tp, _Compare, _Alloc>& __y)"},
{"lineNum":" 1435","line":"    { return !(__y < __x); }"},
{"lineNum":" 1436","line":""},
{"lineNum":" 1437","line":"  /// Based on operator<"},
{"lineNum":" 1438","line":"  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>"},
{"lineNum":" 1439","line":"    inline bool"},
{"lineNum":" 1440","line":"    operator>=(const map<_Key, _Tp, _Compare, _Alloc>& __x,"},
{"lineNum":" 1441","line":"\t       const map<_Key, _Tp, _Compare, _Alloc>& __y)"},
{"lineNum":" 1442","line":"    { return !(__x < __y); }"},
{"lineNum":" 1443","line":""},
{"lineNum":" 1444","line":"  /// See std::map::swap()."},
{"lineNum":" 1445","line":"  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>"},
{"lineNum":" 1446","line":"    inline void"},
{"lineNum":" 1447","line":"    swap(map<_Key, _Tp, _Compare, _Alloc>& __x,"},
{"lineNum":" 1448","line":"\t map<_Key, _Tp, _Compare, _Alloc>& __y)"},
{"lineNum":" 1449","line":"    _GLIBCXX_NOEXCEPT_IF(noexcept(__x.swap(__y)))"},
{"lineNum":" 1450","line":"    { __x.swap(__y); }"},
{"lineNum":" 1451","line":""},
{"lineNum":" 1452","line":"_GLIBCXX_END_NAMESPACE_CONTAINER"},
{"lineNum":" 1453","line":""},
{"lineNum":" 1454","line":"#if __cplusplus > 201402L"},
{"lineNum":" 1455","line":"_GLIBCXX_BEGIN_NAMESPACE_VERSION"},
{"lineNum":" 1456","line":"  // Allow std::map access to internals of compatible maps."},
{"lineNum":" 1457","line":"  template<typename _Key, typename _Val, typename _Cmp1, typename _Alloc,"},
{"lineNum":" 1458","line":"\t   typename _Cmp2>"},
{"lineNum":" 1459","line":"    struct"},
{"lineNum":" 1460","line":"    _Rb_tree_merge_helper<_GLIBCXX_STD_C::map<_Key, _Val, _Cmp1, _Alloc>,"},
{"lineNum":" 1461","line":"\t\t\t  _Cmp2>"},
{"lineNum":" 1462","line":"    {"},
{"lineNum":" 1463","line":"    private:"},
{"lineNum":" 1464","line":"      friend class _GLIBCXX_STD_C::map<_Key, _Val, _Cmp1, _Alloc>;"},
{"lineNum":" 1465","line":""},
{"lineNum":" 1466","line":"      static auto&"},
{"lineNum":" 1467","line":"      _S_get_tree(_GLIBCXX_STD_C::map<_Key, _Val, _Cmp2, _Alloc>& __map)"},
{"lineNum":" 1468","line":"      { return __map._M_t; }"},
{"lineNum":" 1469","line":""},
{"lineNum":" 1470","line":"      static auto&"},
{"lineNum":" 1471","line":"      _S_get_tree(_GLIBCXX_STD_C::multimap<_Key, _Val, _Cmp2, _Alloc>& __map)"},
{"lineNum":" 1472","line":"      { return __map._M_t; }"},
{"lineNum":" 1473","line":"    };"},
{"lineNum":" 1474","line":"_GLIBCXX_END_NAMESPACE_VERSION"},
{"lineNum":" 1475","line":"#endif // C++17"},
{"lineNum":" 1476","line":""},
{"lineNum":" 1477","line":"} // namespace std"},
{"lineNum":" 1478","line":""},
{"lineNum":" 1479","line":"#endif /* _STL_MAP_H */"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "mipl_parser", "date" : "2018-11-28 14:11:03", "instrumented" : 10, "covered" : 10,};
var merged_data = [];
