var data = {lines:[
{"lineNum":"    1","line":"// Stack implementation -*- C++ -*-"},
{"lineNum":"    2","line":""},
{"lineNum":"    3","line":"// Copyright (C) 2001-2017 Free Software Foundation, Inc."},
{"lineNum":"    4","line":"//"},
{"lineNum":"    5","line":"// This file is part of the GNU ISO C++ Library.  This library is free"},
{"lineNum":"    6","line":"// software; you can redistribute it and/or modify it under the"},
{"lineNum":"    7","line":"// terms of the GNU General Public License as published by the"},
{"lineNum":"    8","line":"// Free Software Foundation; either version 3, or (at your option)"},
{"lineNum":"    9","line":"// any later version."},
{"lineNum":"   10","line":""},
{"lineNum":"   11","line":"// This library is distributed in the hope that it will be useful,"},
{"lineNum":"   12","line":"// but WITHOUT ANY WARRANTY; without even the implied warranty of"},
{"lineNum":"   13","line":"// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the"},
{"lineNum":"   14","line":"// GNU General Public License for more details."},
{"lineNum":"   15","line":""},
{"lineNum":"   16","line":"// Under Section 7 of GPL version 3, you are granted additional"},
{"lineNum":"   17","line":"// permissions described in the GCC Runtime Library Exception, version"},
{"lineNum":"   18","line":"// 3.1, as published by the Free Software Foundation."},
{"lineNum":"   19","line":""},
{"lineNum":"   20","line":"// You should have received a copy of the GNU General Public License and"},
{"lineNum":"   21","line":"// a copy of the GCC Runtime Library Exception along with this program;"},
{"lineNum":"   22","line":"// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see"},
{"lineNum":"   23","line":"// <http://www.gnu.org/licenses/>."},
{"lineNum":"   24","line":""},
{"lineNum":"   25","line":"/*"},
{"lineNum":"   26","line":" *"},
{"lineNum":"   27","line":" * Copyright (c) 1994"},
{"lineNum":"   28","line":" * Hewlett-Packard Company"},
{"lineNum":"   29","line":" *"},
{"lineNum":"   30","line":" * Permission to use, copy, modify, distribute and sell this software"},
{"lineNum":"   31","line":" * and its documentation for any purpose is hereby granted without fee,"},
{"lineNum":"   32","line":" * provided that the above copyright notice appear in all copies and"},
{"lineNum":"   33","line":" * that both that copyright notice and this permission notice appear"},
{"lineNum":"   34","line":" * in supporting documentation.  Hewlett-Packard Company makes no"},
{"lineNum":"   35","line":" * representations about the suitability of this software for any"},
{"lineNum":"   36","line":" * purpose.  It is provided \"as is\" without express or implied warranty."},
{"lineNum":"   37","line":" *"},
{"lineNum":"   38","line":" *"},
{"lineNum":"   39","line":" * Copyright (c) 1996,1997"},
{"lineNum":"   40","line":" * Silicon Graphics Computer Systems, Inc."},
{"lineNum":"   41","line":" *"},
{"lineNum":"   42","line":" * Permission to use, copy, modify, distribute and sell this software"},
{"lineNum":"   43","line":" * and its documentation for any purpose is hereby granted without fee,"},
{"lineNum":"   44","line":" * provided that the above copyright notice appear in all copies and"},
{"lineNum":"   45","line":" * that both that copyright notice and this permission notice appear"},
{"lineNum":"   46","line":" * in supporting documentation.  Silicon Graphics makes no"},
{"lineNum":"   47","line":" * representations about the suitability of this software for any"},
{"lineNum":"   48","line":" * purpose.  It is provided \"as is\" without express or implied warranty."},
{"lineNum":"   49","line":" */"},
{"lineNum":"   50","line":""},
{"lineNum":"   51","line":"/** @file bits/stl_stack.h"},
{"lineNum":"   52","line":" *  This is an internal header file, included by other library headers."},
{"lineNum":"   53","line":" *  Do not attempt to use it directly. @headername{stack}"},
{"lineNum":"   54","line":" */"},
{"lineNum":"   55","line":""},
{"lineNum":"   56","line":"#ifndef _STL_STACK_H"},
{"lineNum":"   57","line":"#define _STL_STACK_H 1"},
{"lineNum":"   58","line":""},
{"lineNum":"   59","line":"#include <bits/concept_check.h>"},
{"lineNum":"   60","line":"#include <debug/debug.h>"},
{"lineNum":"   61","line":"#if __cplusplus >= 201103L"},
{"lineNum":"   62","line":"# include <bits/uses_allocator.h>"},
{"lineNum":"   63","line":"#endif"},
{"lineNum":"   64","line":""},
{"lineNum":"   65","line":"namespace std _GLIBCXX_VISIBILITY(default)"},
{"lineNum":"   66","line":"{"},
{"lineNum":"   67","line":"_GLIBCXX_BEGIN_NAMESPACE_VERSION"},
{"lineNum":"   68","line":""},
{"lineNum":"   69","line":"  /**"},
{"lineNum":"   70","line":"   *  @brief  A standard container giving FILO behavior."},
{"lineNum":"   71","line":"   *"},
{"lineNum":"   72","line":"   *  @ingroup sequences"},
{"lineNum":"   73","line":"   *"},
{"lineNum":"   74","line":"   *  @tparam _Tp  Type of element."},
{"lineNum":"   75","line":"   *  @tparam _Sequence  Type of underlying sequence, defaults to deque<_Tp>."},
{"lineNum":"   76","line":"   *"},
{"lineNum":"   77","line":"   *  Meets many of the requirements of a"},
{"lineNum":"   78","line":"   *  <a href=\"tables.html#65\">container</a>,"},
{"lineNum":"   79","line":"   *  but does not define anything to do with iterators.  Very few of the"},
{"lineNum":"   80","line":"   *  other standard container interfaces are defined."},
{"lineNum":"   81","line":"   *"},
{"lineNum":"   82","line":"   *  This is not a true container, but an @e adaptor.  It holds"},
{"lineNum":"   83","line":"   *  another container, and provides a wrapper interface to that"},
{"lineNum":"   84","line":"   *  container.  The wrapper is what enforces strict"},
{"lineNum":"   85","line":"   *  first-in-last-out %stack behavior."},
{"lineNum":"   86","line":"   *"},
{"lineNum":"   87","line":"   *  The second template parameter defines the type of the underlying"},
{"lineNum":"   88","line":"   *  sequence/container.  It defaults to std::deque, but it can be"},
{"lineNum":"   89","line":"   *  any type that supports @c back, @c push_back, and @c pop_back,"},
{"lineNum":"   90","line":"   *  such as std::list, std::vector, or an appropriate user-defined"},
{"lineNum":"   91","line":"   *  type."},
{"lineNum":"   92","line":"   *"},
{"lineNum":"   93","line":"   *  Members not found in @a normal containers are @c container_type,"},
{"lineNum":"   94","line":"   *  which is a typedef for the second Sequence parameter, and @c"},
{"lineNum":"   95","line":"   *  push, @c pop, and @c top, which are standard %stack/FILO"},
{"lineNum":"   96","line":"   *  operations."},
{"lineNum":"   97","line":"  */"},
{"lineNum":"   98","line":"  template<typename _Tp, typename _Sequence = deque<_Tp> >"},
{"lineNum":"   99","line":"    class stack","class":"linePartCov","hits":"2","order":"1598","possible_hits":"3",},
{"lineNum":"  100","line":"    {"},
{"lineNum":"  101","line":"#ifdef _GLIBCXX_CONCEPT_CHECKS"},
{"lineNum":"  102","line":"      // concept requirements"},
{"lineNum":"  103","line":"      typedef typename _Sequence::value_type _Sequence_value_type;"},
{"lineNum":"  104","line":"# if __cplusplus < 201103L"},
{"lineNum":"  105","line":"      __glibcxx_class_requires(_Tp, _SGIAssignableConcept)"},
{"lineNum":"  106","line":"      __glibcxx_class_requires(_Sequence, _BackInsertionSequenceConcept)"},
{"lineNum":"  107","line":"# endif"},
{"lineNum":"  108","line":"      __glibcxx_class_requires2(_Tp, _Sequence_value_type, _SameTypeConcept)"},
{"lineNum":"  109","line":"#endif"},
{"lineNum":"  110","line":""},
{"lineNum":"  111","line":"      template<typename _Tp1, typename _Seq1>"},
{"lineNum":"  112","line":"\tfriend bool"},
{"lineNum":"  113","line":"\toperator==(const stack<_Tp1, _Seq1>&, const stack<_Tp1, _Seq1>&);"},
{"lineNum":"  114","line":""},
{"lineNum":"  115","line":"      template<typename _Tp1, typename _Seq1>"},
{"lineNum":"  116","line":"\tfriend bool"},
{"lineNum":"  117","line":"\toperator<(const stack<_Tp1, _Seq1>&, const stack<_Tp1, _Seq1>&);"},
{"lineNum":"  118","line":""},
{"lineNum":"  119","line":"#if __cplusplus >= 201103L"},
{"lineNum":"  120","line":"      template<typename _Alloc>"},
{"lineNum":"  121","line":"\tusing _Uses = typename"},
{"lineNum":"  122","line":"\t  enable_if<uses_allocator<_Sequence, _Alloc>::value>::type;"},
{"lineNum":"  123","line":"#endif"},
{"lineNum":"  124","line":""},
{"lineNum":"  125","line":"    public:"},
{"lineNum":"  126","line":"      typedef typename _Sequence::value_type\t\tvalue_type;"},
{"lineNum":"  127","line":"      typedef typename _Sequence::reference\t\treference;"},
{"lineNum":"  128","line":"      typedef typename _Sequence::const_reference\tconst_reference;"},
{"lineNum":"  129","line":"      typedef typename _Sequence::size_type\t\tsize_type;"},
{"lineNum":"  130","line":"      typedef\t       _Sequence\t\t\tcontainer_type;"},
{"lineNum":"  131","line":""},
{"lineNum":"  132","line":"    protected:"},
{"lineNum":"  133","line":"      //  See queue::c for notes on this name."},
{"lineNum":"  134","line":"      _Sequence c;"},
{"lineNum":"  135","line":""},
{"lineNum":"  136","line":"    public:"},
{"lineNum":"  137","line":"      // XXX removed old def ctor, added def arg to this one to match 14882"},
{"lineNum":"  138","line":"      /**"},
{"lineNum":"  139","line":"       *  @brief  Default constructor creates no elements."},
{"lineNum":"  140","line":"       */"},
{"lineNum":"  141","line":"#if __cplusplus < 201103L"},
{"lineNum":"  142","line":"      explicit"},
{"lineNum":"  143","line":"      stack(const _Sequence& __c = _Sequence())"},
{"lineNum":"  144","line":"      : c(__c) { }"},
{"lineNum":"  145","line":"#else"},
{"lineNum":"  146","line":"      template<typename _Seq = _Sequence, typename _Requires = typename"},
{"lineNum":"  147","line":"\t       enable_if<is_default_constructible<_Seq>::value>::type>"},
{"lineNum":"  148","line":"\tstack()","class":"lineCov","hits":"1","order":"169","possible_hits":"1",},
{"lineNum":"  149","line":"\t: c() { }","class":"linePartCov","hits":"1","order":"170","possible_hits":"2",},
{"lineNum":"  150","line":""},
{"lineNum":"  151","line":"      explicit"},
{"lineNum":"  152","line":"      stack(const _Sequence& __c)"},
{"lineNum":"  153","line":"      : c(__c) { }"},
{"lineNum":"  154","line":""},
{"lineNum":"  155","line":"      explicit"},
{"lineNum":"  156","line":"      stack(_Sequence&& __c)"},
{"lineNum":"  157","line":"      : c(std::move(__c)) { }"},
{"lineNum":"  158","line":""},
{"lineNum":"  159","line":"      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>"},
{"lineNum":"  160","line":"\texplicit"},
{"lineNum":"  161","line":"\tstack(const _Alloc& __a)"},
{"lineNum":"  162","line":"\t: c(__a) { }"},
{"lineNum":"  163","line":""},
{"lineNum":"  164","line":"      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>"},
{"lineNum":"  165","line":"\tstack(const _Sequence& __c, const _Alloc& __a)"},
{"lineNum":"  166","line":"\t: c(__c, __a) { }"},
{"lineNum":"  167","line":""},
{"lineNum":"  168","line":"      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>"},
{"lineNum":"  169","line":"\tstack(_Sequence&& __c, const _Alloc& __a)"},
{"lineNum":"  170","line":"\t: c(std::move(__c), __a) { }"},
{"lineNum":"  171","line":""},
{"lineNum":"  172","line":"      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>"},
{"lineNum":"  173","line":"\tstack(const stack& __q, const _Alloc& __a)"},
{"lineNum":"  174","line":"\t: c(__q.c, __a) { }"},
{"lineNum":"  175","line":""},
{"lineNum":"  176","line":"      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>"},
{"lineNum":"  177","line":"\tstack(stack&& __q, const _Alloc& __a)"},
{"lineNum":"  178","line":"\t: c(std::move(__q.c), __a) { }"},
{"lineNum":"  179","line":"#endif"},
{"lineNum":"  180","line":""},
{"lineNum":"  181","line":"      /**"},
{"lineNum":"  182","line":"       *  Returns true if the %stack is empty."},
{"lineNum":"  183","line":"       */"},
{"lineNum":"  184","line":"      bool"},
{"lineNum":"  185","line":"      empty() const","class":"lineCov","hits":"1","order":"1060","possible_hits":"1",},
{"lineNum":"  186","line":"      { return c.empty(); }","class":"linePartCov","hits":"1","order":"1061","possible_hits":"2",},
{"lineNum":"  187","line":""},
{"lineNum":"  188","line":"      /**  Returns the number of elements in the %stack.  */"},
{"lineNum":"  189","line":"      size_type"},
{"lineNum":"  190","line":"      size() const"},
{"lineNum":"  191","line":"      { return c.size(); }"},
{"lineNum":"  192","line":""},
{"lineNum":"  193","line":"      /**"},
{"lineNum":"  194","line":"       *  Returns a read/write reference to the data at the first"},
{"lineNum":"  195","line":"       *  element of the %stack."},
{"lineNum":"  196","line":"       */"},
{"lineNum":"  197","line":"      reference"},
{"lineNum":"  198","line":"      top()","class":"lineCov","hits":"1","order":"840","possible_hits":"1",},
{"lineNum":"  199","line":"      {"},
{"lineNum":"  200","line":"\t__glibcxx_requires_nonempty();"},
{"lineNum":"  201","line":"\treturn c.back();","class":"lineCov","hits":"1","order":"841","possible_hits":"1",},
{"lineNum":"  202","line":"      }","class":"linePartCov","hits":"1","order":"859","possible_hits":"2",},
{"lineNum":"  203","line":""},
{"lineNum":"  204","line":"      /**"},
{"lineNum":"  205","line":"       *  Returns a read-only (constant) reference to the data at the first"},
{"lineNum":"  206","line":"       *  element of the %stack."},
{"lineNum":"  207","line":"       */"},
{"lineNum":"  208","line":"      const_reference"},
{"lineNum":"  209","line":"      top() const"},
{"lineNum":"  210","line":"      {"},
{"lineNum":"  211","line":"\t__glibcxx_requires_nonempty();"},
{"lineNum":"  212","line":"\treturn c.back();"},
{"lineNum":"  213","line":"      }"},
{"lineNum":"  214","line":""},
{"lineNum":"  215","line":"      /**"},
{"lineNum":"  216","line":"       *  @brief  Add data to the top of the %stack."},
{"lineNum":"  217","line":"       *  @param  __x  Data to be added."},
{"lineNum":"  218","line":"       *"},
{"lineNum":"  219","line":"       *  This is a typical %stack operation.  The function creates an"},
{"lineNum":"  220","line":"       *  element at the top of the %stack and assigns the given data"},
{"lineNum":"  221","line":"       *  to it.  The time complexity of the operation depends on the"},
{"lineNum":"  222","line":"       *  underlying sequence."},
{"lineNum":"  223","line":"       */"},
{"lineNum":"  224","line":"      void"},
{"lineNum":"  225","line":"      push(const value_type& __x)","class":"lineCov","hits":"1","order":"1127","possible_hits":"1",},
{"lineNum":"  226","line":"      { c.push_back(__x); }","class":"linePartCov","hits":"1","order":"1128","possible_hits":"2",},
{"lineNum":"  227","line":""},
{"lineNum":"  228","line":"#if __cplusplus >= 201103L"},
{"lineNum":"  229","line":"      void"},
{"lineNum":"  230","line":"      push(value_type&& __x)","class":"lineCov","hits":"1","order":"750","possible_hits":"1",},
{"lineNum":"  231","line":"      { c.push_back(std::move(__x)); }","class":"linePartCov","hits":"1","order":"751","possible_hits":"2",},
{"lineNum":"  232","line":""},
{"lineNum":"  233","line":"#if __cplusplus > 201402L"},
{"lineNum":"  234","line":"      template<typename... _Args>"},
{"lineNum":"  235","line":"\tdecltype(auto)"},
{"lineNum":"  236","line":"\templace(_Args&&... __args)"},
{"lineNum":"  237","line":"\t{ return c.emplace_back(std::forward<_Args>(__args)...); }"},
{"lineNum":"  238","line":"#else"},
{"lineNum":"  239","line":"      template<typename... _Args>"},
{"lineNum":"  240","line":"\tvoid"},
{"lineNum":"  241","line":"\templace(_Args&&... __args)"},
{"lineNum":"  242","line":"\t{ c.emplace_back(std::forward<_Args>(__args)...); }"},
{"lineNum":"  243","line":"#endif"},
{"lineNum":"  244","line":"#endif"},
{"lineNum":"  245","line":""},
{"lineNum":"  246","line":"      /**"},
{"lineNum":"  247","line":"       *  @brief  Removes first element."},
{"lineNum":"  248","line":"       *"},
{"lineNum":"  249","line":"       *  This is a typical %stack operation.  It shrinks the %stack"},
{"lineNum":"  250","line":"       *  by one.  The time complexity of the operation depends on the"},
{"lineNum":"  251","line":"       *  underlying sequence."},
{"lineNum":"  252","line":"       *"},
{"lineNum":"  253","line":"       *  Note that no data is returned, and if the first element\'s"},
{"lineNum":"  254","line":"       *  data is needed, it should be retrieved before pop() is"},
{"lineNum":"  255","line":"       *  called."},
{"lineNum":"  256","line":"       */"},
{"lineNum":"  257","line":"      void"},
{"lineNum":"  258","line":"      pop()","class":"lineCov","hits":"1","order":"1092","possible_hits":"1",},
{"lineNum":"  259","line":"      {"},
{"lineNum":"  260","line":"\t__glibcxx_requires_nonempty();"},
{"lineNum":"  261","line":"\tc.pop_back();","class":"lineCov","hits":"1","order":"1093","possible_hits":"1",},
{"lineNum":"  262","line":"      }","class":"linePartCov","hits":"1","order":"1103","possible_hits":"2",},
{"lineNum":"  263","line":""},
{"lineNum":"  264","line":"#if __cplusplus >= 201103L"},
{"lineNum":"  265","line":"      void"},
{"lineNum":"  266","line":"      swap(stack& __s)"},
{"lineNum":"  267","line":"#if __cplusplus > 201402L || !defined(__STRICT_ANSI__) // c++1z or gnu++11"},
{"lineNum":"  268","line":"      noexcept(__is_nothrow_swappable<_Sequence>::value)"},
{"lineNum":"  269","line":"#else"},
{"lineNum":"  270","line":"      noexcept(__is_nothrow_swappable<_Tp>::value)"},
{"lineNum":"  271","line":"#endif"},
{"lineNum":"  272","line":"      {"},
{"lineNum":"  273","line":"\tusing std::swap;"},
{"lineNum":"  274","line":"\tswap(c, __s.c);"},
{"lineNum":"  275","line":"      }"},
{"lineNum":"  276","line":"#endif // __cplusplus >= 201103L"},
{"lineNum":"  277","line":"    };"},
{"lineNum":"  278","line":""},
{"lineNum":"  279","line":"  /**"},
{"lineNum":"  280","line":"   *  @brief  Stack equality comparison."},
{"lineNum":"  281","line":"   *  @param  __x  A %stack."},
{"lineNum":"  282","line":"   *  @param  __y  A %stack of the same type as @a __x."},
{"lineNum":"  283","line":"   *  @return  True iff the size and elements of the stacks are equal."},
{"lineNum":"  284","line":"   *"},
{"lineNum":"  285","line":"   *  This is an equivalence relation.  Complexity and semantics"},
{"lineNum":"  286","line":"   *  depend on the underlying sequence type, but the expected rules"},
{"lineNum":"  287","line":"   *  are: this relation is linear in the size of the sequences, and"},
{"lineNum":"  288","line":"   *  stacks are considered equivalent if their sequences compare"},
{"lineNum":"  289","line":"   *  equal."},
{"lineNum":"  290","line":"  */"},
{"lineNum":"  291","line":"  template<typename _Tp, typename _Seq>"},
{"lineNum":"  292","line":"    inline bool"},
{"lineNum":"  293","line":"    operator==(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)"},
{"lineNum":"  294","line":"    { return __x.c == __y.c; }"},
{"lineNum":"  295","line":""},
{"lineNum":"  296","line":"  /**"},
{"lineNum":"  297","line":"   *  @brief  Stack ordering relation."},
{"lineNum":"  298","line":"   *  @param  __x  A %stack."},
{"lineNum":"  299","line":"   *  @param  __y  A %stack of the same type as @a x."},
{"lineNum":"  300","line":"   *  @return  True iff @a x is lexicographically less than @a __y."},
{"lineNum":"  301","line":"   *"},
{"lineNum":"  302","line":"   *  This is an total ordering relation.  Complexity and semantics"},
{"lineNum":"  303","line":"   *  depend on the underlying sequence type, but the expected rules"},
{"lineNum":"  304","line":"   *  are: this relation is linear in the size of the sequences, the"},
{"lineNum":"  305","line":"   *  elements must be comparable with @c <, and"},
{"lineNum":"  306","line":"   *  std::lexicographical_compare() is usually used to make the"},
{"lineNum":"  307","line":"   *  determination."},
{"lineNum":"  308","line":"  */"},
{"lineNum":"  309","line":"  template<typename _Tp, typename _Seq>"},
{"lineNum":"  310","line":"    inline bool"},
{"lineNum":"  311","line":"    operator<(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)"},
{"lineNum":"  312","line":"    { return __x.c < __y.c; }"},
{"lineNum":"  313","line":""},
{"lineNum":"  314","line":"  /// Based on operator=="},
{"lineNum":"  315","line":"  template<typename _Tp, typename _Seq>"},
{"lineNum":"  316","line":"    inline bool"},
{"lineNum":"  317","line":"    operator!=(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)"},
{"lineNum":"  318","line":"    { return !(__x == __y); }"},
{"lineNum":"  319","line":""},
{"lineNum":"  320","line":"  /// Based on operator<"},
{"lineNum":"  321","line":"  template<typename _Tp, typename _Seq>"},
{"lineNum":"  322","line":"    inline bool"},
{"lineNum":"  323","line":"    operator>(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)"},
{"lineNum":"  324","line":"    { return __y < __x; }"},
{"lineNum":"  325","line":""},
{"lineNum":"  326","line":"  /// Based on operator<"},
{"lineNum":"  327","line":"  template<typename _Tp, typename _Seq>"},
{"lineNum":"  328","line":"    inline bool"},
{"lineNum":"  329","line":"    operator<=(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)"},
{"lineNum":"  330","line":"    { return !(__y < __x); }"},
{"lineNum":"  331","line":""},
{"lineNum":"  332","line":"  /// Based on operator<"},
{"lineNum":"  333","line":"  template<typename _Tp, typename _Seq>"},
{"lineNum":"  334","line":"    inline bool"},
{"lineNum":"  335","line":"    operator>=(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)"},
{"lineNum":"  336","line":"    { return !(__x < __y); }"},
{"lineNum":"  337","line":""},
{"lineNum":"  338","line":"#if __cplusplus >= 201103L"},
{"lineNum":"  339","line":"  template<typename _Tp, typename _Seq>"},
{"lineNum":"  340","line":"    inline"},
{"lineNum":"  341","line":"#if __cplusplus > 201402L || !defined(__STRICT_ANSI__) // c++1z or gnu++11"},
{"lineNum":"  342","line":"    // Constrained free swap overload, see p0185r1"},
{"lineNum":"  343","line":"    typename enable_if<__is_swappable<_Seq>::value>::type"},
{"lineNum":"  344","line":"#else"},
{"lineNum":"  345","line":"    void"},
{"lineNum":"  346","line":"#endif"},
{"lineNum":"  347","line":"    swap(stack<_Tp, _Seq>& __x, stack<_Tp, _Seq>& __y)"},
{"lineNum":"  348","line":"    noexcept(noexcept(__x.swap(__y)))"},
{"lineNum":"  349","line":"    { __x.swap(__y); }"},
{"lineNum":"  350","line":""},
{"lineNum":"  351","line":"  template<typename _Tp, typename _Seq, typename _Alloc>"},
{"lineNum":"  352","line":"    struct uses_allocator<stack<_Tp, _Seq>, _Alloc>"},
{"lineNum":"  353","line":"    : public uses_allocator<_Seq, _Alloc>::type { };"},
{"lineNum":"  354","line":"#endif // __cplusplus >= 201103L"},
{"lineNum":"  355","line":""},
{"lineNum":"  356","line":"_GLIBCXX_END_NAMESPACE_VERSION"},
{"lineNum":"  357","line":"} // namespace"},
{"lineNum":"  358","line":""},
{"lineNum":"  359","line":"#endif /* _STL_STACK_H */"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "mipl_parser", "date" : "2018-11-28 14:11:04", "instrumented" : 15, "covered" : 15,};
var merged_data = [];
