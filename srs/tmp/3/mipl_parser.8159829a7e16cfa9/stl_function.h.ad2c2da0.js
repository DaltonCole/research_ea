var data = {lines:[
{"lineNum":"    1","line":"// Functor implementations -*- C++ -*-"},
{"lineNum":"    2","line":""},
{"lineNum":"    3","line":"// Copyright (C) 2001-2017 Free Software Foundation, Inc."},
{"lineNum":"    4","line":"//"},
{"lineNum":"    5","line":"// This file is part of the GNU ISO C++ Library.  This library is free"},
{"lineNum":"    6","line":"// software; you can redistribute it and/or modify it under the"},
{"lineNum":"    7","line":"// terms of the GNU General Public License as published by the"},
{"lineNum":"    8","line":"// Free Software Foundation; either version 3, or (at your option)"},
{"lineNum":"    9","line":"// any later version."},
{"lineNum":"   10","line":""},
{"lineNum":"   11","line":"// This library is distributed in the hope that it will be useful,"},
{"lineNum":"   12","line":"// but WITHOUT ANY WARRANTY; without even the implied warranty of"},
{"lineNum":"   13","line":"// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the"},
{"lineNum":"   14","line":"// GNU General Public License for more details."},
{"lineNum":"   15","line":""},
{"lineNum":"   16","line":"// Under Section 7 of GPL version 3, you are granted additional"},
{"lineNum":"   17","line":"// permissions described in the GCC Runtime Library Exception, version"},
{"lineNum":"   18","line":"// 3.1, as published by the Free Software Foundation."},
{"lineNum":"   19","line":""},
{"lineNum":"   20","line":"// You should have received a copy of the GNU General Public License and"},
{"lineNum":"   21","line":"// a copy of the GCC Runtime Library Exception along with this program;"},
{"lineNum":"   22","line":"// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see"},
{"lineNum":"   23","line":"// <http://www.gnu.org/licenses/>."},
{"lineNum":"   24","line":""},
{"lineNum":"   25","line":"/*"},
{"lineNum":"   26","line":" *"},
{"lineNum":"   27","line":" * Copyright (c) 1994"},
{"lineNum":"   28","line":" * Hewlett-Packard Company"},
{"lineNum":"   29","line":" *"},
{"lineNum":"   30","line":" * Permission to use, copy, modify, distribute and sell this software"},
{"lineNum":"   31","line":" * and its documentation for any purpose is hereby granted without fee,"},
{"lineNum":"   32","line":" * provided that the above copyright notice appear in all copies and"},
{"lineNum":"   33","line":" * that both that copyright notice and this permission notice appear"},
{"lineNum":"   34","line":" * in supporting documentation.  Hewlett-Packard Company makes no"},
{"lineNum":"   35","line":" * representations about the suitability of this software for any"},
{"lineNum":"   36","line":" * purpose.  It is provided \"as is\" without express or implied warranty."},
{"lineNum":"   37","line":" *"},
{"lineNum":"   38","line":" *"},
{"lineNum":"   39","line":" * Copyright (c) 1996-1998"},
{"lineNum":"   40","line":" * Silicon Graphics Computer Systems, Inc."},
{"lineNum":"   41","line":" *"},
{"lineNum":"   42","line":" * Permission to use, copy, modify, distribute and sell this software"},
{"lineNum":"   43","line":" * and its documentation for any purpose is hereby granted without fee,"},
{"lineNum":"   44","line":" * provided that the above copyright notice appear in all copies and"},
{"lineNum":"   45","line":" * that both that copyright notice and this permission notice appear"},
{"lineNum":"   46","line":" * in supporting documentation.  Silicon Graphics makes no"},
{"lineNum":"   47","line":" * representations about the suitability of this software for any"},
{"lineNum":"   48","line":" * purpose.  It is provided \"as is\" without express or implied warranty."},
{"lineNum":"   49","line":" */"},
{"lineNum":"   50","line":""},
{"lineNum":"   51","line":"/** @file bits/stl_function.h"},
{"lineNum":"   52","line":" *  This is an internal header file, included by other library headers."},
{"lineNum":"   53","line":" *  Do not attempt to use it directly. @headername{functional}"},
{"lineNum":"   54","line":" */"},
{"lineNum":"   55","line":""},
{"lineNum":"   56","line":"#ifndef _STL_FUNCTION_H"},
{"lineNum":"   57","line":"#define _STL_FUNCTION_H 1"},
{"lineNum":"   58","line":""},
{"lineNum":"   59","line":"#if __cplusplus > 201103L"},
{"lineNum":"   60","line":"#include <bits/move.h>"},
{"lineNum":"   61","line":"#endif"},
{"lineNum":"   62","line":""},
{"lineNum":"   63","line":"namespace std _GLIBCXX_VISIBILITY(default)"},
{"lineNum":"   64","line":"{"},
{"lineNum":"   65","line":"_GLIBCXX_BEGIN_NAMESPACE_VERSION"},
{"lineNum":"   66","line":""},
{"lineNum":"   67","line":"  // 20.3.1 base classes"},
{"lineNum":"   68","line":"  /** @defgroup functors Function Objects"},
{"lineNum":"   69","line":"   * @ingroup utilities"},
{"lineNum":"   70","line":"   *"},
{"lineNum":"   71","line":"   *  Function objects, or @e functors, are objects with an @c operator()"},
{"lineNum":"   72","line":"   *  defined and accessible.  They can be passed as arguments to algorithm"},
{"lineNum":"   73","line":"   *  templates and used in place of a function pointer.  Not only is the"},
{"lineNum":"   74","line":"   *  resulting expressiveness of the library increased, but the generated"},
{"lineNum":"   75","line":"   *  code can be more efficient than what you might write by hand.  When we"},
{"lineNum":"   76","line":"   *  refer to @a functors, then, generally we include function pointers in"},
{"lineNum":"   77","line":"   *  the description as well."},
{"lineNum":"   78","line":"   *"},
{"lineNum":"   79","line":"   *  Often, functors are only created as temporaries passed to algorithm"},
{"lineNum":"   80","line":"   *  calls, rather than being created as named variables."},
{"lineNum":"   81","line":"   *"},
{"lineNum":"   82","line":"   *  Two examples taken from the standard itself follow.  To perform a"},
{"lineNum":"   83","line":"   *  by-element addition of two vectors @c a and @c b containing @c double,"},
{"lineNum":"   84","line":"   *  and put the result in @c a, use"},
{"lineNum":"   85","line":"   *  \\code"},
{"lineNum":"   86","line":"   *  transform (a.begin(), a.end(), b.begin(), a.begin(), plus<double>());"},
{"lineNum":"   87","line":"   *  \\endcode"},
{"lineNum":"   88","line":"   *  To negate every element in @c a, use"},
{"lineNum":"   89","line":"   *  \\code"},
{"lineNum":"   90","line":"   *  transform(a.begin(), a.end(), a.begin(), negate<double>());"},
{"lineNum":"   91","line":"   *  \\endcode"},
{"lineNum":"   92","line":"   *  The addition and negation functions will be inlined directly."},
{"lineNum":"   93","line":"   *"},
{"lineNum":"   94","line":"   *  The standard functors are derived from structs named @c unary_function"},
{"lineNum":"   95","line":"   *  and @c binary_function.  These two classes contain nothing but typedefs,"},
{"lineNum":"   96","line":"   *  to aid in generic (template) programming.  If you write your own"},
{"lineNum":"   97","line":"   *  functors, you might consider doing the same."},
{"lineNum":"   98","line":"   *"},
{"lineNum":"   99","line":"   *  @{"},
{"lineNum":"  100","line":"   */"},
{"lineNum":"  101","line":"  /**"},
{"lineNum":"  102","line":"   *  This is one of the @link functors functor base classes@endlink."},
{"lineNum":"  103","line":"   */"},
{"lineNum":"  104","line":"  template<typename _Arg, typename _Result>"},
{"lineNum":"  105","line":"    struct unary_function"},
{"lineNum":"  106","line":"    {"},
{"lineNum":"  107","line":"      /// @c argument_type is the type of the argument"},
{"lineNum":"  108","line":"      typedef _Arg \targument_type;"},
{"lineNum":"  109","line":""},
{"lineNum":"  110","line":"      /// @c result_type is the return type"},
{"lineNum":"  111","line":"      typedef _Result \tresult_type;"},
{"lineNum":"  112","line":"    };"},
{"lineNum":"  113","line":""},
{"lineNum":"  114","line":"  /**"},
{"lineNum":"  115","line":"   *  This is one of the @link functors functor base classes@endlink."},
{"lineNum":"  116","line":"   */"},
{"lineNum":"  117","line":"  template<typename _Arg1, typename _Arg2, typename _Result>"},
{"lineNum":"  118","line":"    struct binary_function"},
{"lineNum":"  119","line":"    {"},
{"lineNum":"  120","line":"      /// @c first_argument_type is the type of the first argument"},
{"lineNum":"  121","line":"      typedef _Arg1 \tfirst_argument_type;"},
{"lineNum":"  122","line":""},
{"lineNum":"  123","line":"      /// @c second_argument_type is the type of the second argument"},
{"lineNum":"  124","line":"      typedef _Arg2 \tsecond_argument_type;"},
{"lineNum":"  125","line":""},
{"lineNum":"  126","line":"      /// @c result_type is the return type"},
{"lineNum":"  127","line":"      typedef _Result \tresult_type;"},
{"lineNum":"  128","line":"    };"},
{"lineNum":"  129","line":"  /** @}  */"},
{"lineNum":"  130","line":""},
{"lineNum":"  131","line":"  // 20.3.2 arithmetic"},
{"lineNum":"  132","line":"  /** @defgroup arithmetic_functors Arithmetic Classes"},
{"lineNum":"  133","line":"   * @ingroup functors"},
{"lineNum":"  134","line":"   *"},
{"lineNum":"  135","line":"   *  Because basic math often needs to be done during an algorithm,"},
{"lineNum":"  136","line":"   *  the library provides functors for those operations.  See the"},
{"lineNum":"  137","line":"   *  documentation for @link functors the base classes@endlink"},
{"lineNum":"  138","line":"   *  for examples of their use."},
{"lineNum":"  139","line":"   *"},
{"lineNum":"  140","line":"   *  @{"},
{"lineNum":"  141","line":"   */"},
{"lineNum":"  142","line":""},
{"lineNum":"  143","line":"#if __cplusplus > 201103L"},
{"lineNum":"  144","line":"  struct __is_transparent;  // undefined"},
{"lineNum":"  145","line":""},
{"lineNum":"  146","line":"  template<typename _Tp = void>"},
{"lineNum":"  147","line":"    struct plus;"},
{"lineNum":"  148","line":""},
{"lineNum":"  149","line":"  template<typename _Tp = void>"},
{"lineNum":"  150","line":"    struct minus;"},
{"lineNum":"  151","line":""},
{"lineNum":"  152","line":"  template<typename _Tp = void>"},
{"lineNum":"  153","line":"    struct multiplies;"},
{"lineNum":"  154","line":""},
{"lineNum":"  155","line":"  template<typename _Tp = void>"},
{"lineNum":"  156","line":"    struct divides;"},
{"lineNum":"  157","line":""},
{"lineNum":"  158","line":"  template<typename _Tp = void>"},
{"lineNum":"  159","line":"    struct modulus;"},
{"lineNum":"  160","line":""},
{"lineNum":"  161","line":"  template<typename _Tp = void>"},
{"lineNum":"  162","line":"    struct negate;"},
{"lineNum":"  163","line":"#endif"},
{"lineNum":"  164","line":""},
{"lineNum":"  165","line":"  /// One of the @link arithmetic_functors math functors@endlink."},
{"lineNum":"  166","line":"  template<typename _Tp>"},
{"lineNum":"  167","line":"    struct plus : public binary_function<_Tp, _Tp, _Tp>"},
{"lineNum":"  168","line":"    {"},
{"lineNum":"  169","line":"      _GLIBCXX14_CONSTEXPR"},
{"lineNum":"  170","line":"      _Tp"},
{"lineNum":"  171","line":"      operator()(const _Tp& __x, const _Tp& __y) const"},
{"lineNum":"  172","line":"      { return __x + __y; }"},
{"lineNum":"  173","line":"    };"},
{"lineNum":"  174","line":""},
{"lineNum":"  175","line":"  /// One of the @link arithmetic_functors math functors@endlink."},
{"lineNum":"  176","line":"  template<typename _Tp>"},
{"lineNum":"  177","line":"    struct minus : public binary_function<_Tp, _Tp, _Tp>"},
{"lineNum":"  178","line":"    {"},
{"lineNum":"  179","line":"      _GLIBCXX14_CONSTEXPR"},
{"lineNum":"  180","line":"      _Tp"},
{"lineNum":"  181","line":"      operator()(const _Tp& __x, const _Tp& __y) const"},
{"lineNum":"  182","line":"      { return __x - __y; }"},
{"lineNum":"  183","line":"    };"},
{"lineNum":"  184","line":""},
{"lineNum":"  185","line":"  /// One of the @link arithmetic_functors math functors@endlink."},
{"lineNum":"  186","line":"  template<typename _Tp>"},
{"lineNum":"  187","line":"    struct multiplies : public binary_function<_Tp, _Tp, _Tp>"},
{"lineNum":"  188","line":"    {"},
{"lineNum":"  189","line":"      _GLIBCXX14_CONSTEXPR"},
{"lineNum":"  190","line":"      _Tp"},
{"lineNum":"  191","line":"      operator()(const _Tp& __x, const _Tp& __y) const"},
{"lineNum":"  192","line":"      { return __x * __y; }"},
{"lineNum":"  193","line":"    };"},
{"lineNum":"  194","line":""},
{"lineNum":"  195","line":"  /// One of the @link arithmetic_functors math functors@endlink."},
{"lineNum":"  196","line":"  template<typename _Tp>"},
{"lineNum":"  197","line":"    struct divides : public binary_function<_Tp, _Tp, _Tp>"},
{"lineNum":"  198","line":"    {"},
{"lineNum":"  199","line":"      _GLIBCXX14_CONSTEXPR"},
{"lineNum":"  200","line":"      _Tp"},
{"lineNum":"  201","line":"      operator()(const _Tp& __x, const _Tp& __y) const"},
{"lineNum":"  202","line":"      { return __x / __y; }"},
{"lineNum":"  203","line":"    };"},
{"lineNum":"  204","line":""},
{"lineNum":"  205","line":"  /// One of the @link arithmetic_functors math functors@endlink."},
{"lineNum":"  206","line":"  template<typename _Tp>"},
{"lineNum":"  207","line":"    struct modulus : public binary_function<_Tp, _Tp, _Tp>"},
{"lineNum":"  208","line":"    {"},
{"lineNum":"  209","line":"      _GLIBCXX14_CONSTEXPR"},
{"lineNum":"  210","line":"      _Tp"},
{"lineNum":"  211","line":"      operator()(const _Tp& __x, const _Tp& __y) const"},
{"lineNum":"  212","line":"      { return __x % __y; }"},
{"lineNum":"  213","line":"    };"},
{"lineNum":"  214","line":""},
{"lineNum":"  215","line":"  /// One of the @link arithmetic_functors math functors@endlink."},
{"lineNum":"  216","line":"  template<typename _Tp>"},
{"lineNum":"  217","line":"    struct negate : public unary_function<_Tp, _Tp>"},
{"lineNum":"  218","line":"    {"},
{"lineNum":"  219","line":"      _GLIBCXX14_CONSTEXPR"},
{"lineNum":"  220","line":"      _Tp"},
{"lineNum":"  221","line":"      operator()(const _Tp& __x) const"},
{"lineNum":"  222","line":"      { return -__x; }"},
{"lineNum":"  223","line":"    };"},
{"lineNum":"  224","line":""},
{"lineNum":"  225","line":"#if __cplusplus > 201103L"},
{"lineNum":"  226","line":""},
{"lineNum":"  227","line":"#define __cpp_lib_transparent_operators 201510"},
{"lineNum":"  228","line":""},
{"lineNum":"  229","line":"  template<>"},
{"lineNum":"  230","line":"    struct plus<void>"},
{"lineNum":"  231","line":"    {"},
{"lineNum":"  232","line":"      template <typename _Tp, typename _Up>"},
{"lineNum":"  233","line":"\t_GLIBCXX14_CONSTEXPR"},
{"lineNum":"  234","line":"\tauto"},
{"lineNum":"  235","line":"\toperator()(_Tp&& __t, _Up&& __u) const"},
{"lineNum":"  236","line":"\tnoexcept(noexcept(std::forward<_Tp>(__t) + std::forward<_Up>(__u)))"},
{"lineNum":"  237","line":"\t-> decltype(std::forward<_Tp>(__t) + std::forward<_Up>(__u))"},
{"lineNum":"  238","line":"\t{ return std::forward<_Tp>(__t) + std::forward<_Up>(__u); }"},
{"lineNum":"  239","line":""},
{"lineNum":"  240","line":"      typedef __is_transparent is_transparent;"},
{"lineNum":"  241","line":"    };"},
{"lineNum":"  242","line":""},
{"lineNum":"  243","line":"  /// One of the @link arithmetic_functors math functors@endlink."},
{"lineNum":"  244","line":"  template<>"},
{"lineNum":"  245","line":"    struct minus<void>"},
{"lineNum":"  246","line":"    {"},
{"lineNum":"  247","line":"      template <typename _Tp, typename _Up>"},
{"lineNum":"  248","line":"\t_GLIBCXX14_CONSTEXPR"},
{"lineNum":"  249","line":"\tauto"},
{"lineNum":"  250","line":"\toperator()(_Tp&& __t, _Up&& __u) const"},
{"lineNum":"  251","line":"\tnoexcept(noexcept(std::forward<_Tp>(__t) - std::forward<_Up>(__u)))"},
{"lineNum":"  252","line":"\t-> decltype(std::forward<_Tp>(__t) - std::forward<_Up>(__u))"},
{"lineNum":"  253","line":"\t{ return std::forward<_Tp>(__t) - std::forward<_Up>(__u); }"},
{"lineNum":"  254","line":""},
{"lineNum":"  255","line":"      typedef __is_transparent is_transparent;"},
{"lineNum":"  256","line":"    };"},
{"lineNum":"  257","line":""},
{"lineNum":"  258","line":"  /// One of the @link arithmetic_functors math functors@endlink."},
{"lineNum":"  259","line":"  template<>"},
{"lineNum":"  260","line":"    struct multiplies<void>"},
{"lineNum":"  261","line":"    {"},
{"lineNum":"  262","line":"      template <typename _Tp, typename _Up>"},
{"lineNum":"  263","line":"\t_GLIBCXX14_CONSTEXPR"},
{"lineNum":"  264","line":"\tauto"},
{"lineNum":"  265","line":"\toperator()(_Tp&& __t, _Up&& __u) const"},
{"lineNum":"  266","line":"\tnoexcept(noexcept(std::forward<_Tp>(__t) * std::forward<_Up>(__u)))"},
{"lineNum":"  267","line":"\t-> decltype(std::forward<_Tp>(__t) * std::forward<_Up>(__u))"},
{"lineNum":"  268","line":"\t{ return std::forward<_Tp>(__t) * std::forward<_Up>(__u); }"},
{"lineNum":"  269","line":""},
{"lineNum":"  270","line":"      typedef __is_transparent is_transparent;"},
{"lineNum":"  271","line":"    };"},
{"lineNum":"  272","line":""},
{"lineNum":"  273","line":"  /// One of the @link arithmetic_functors math functors@endlink."},
{"lineNum":"  274","line":"  template<>"},
{"lineNum":"  275","line":"    struct divides<void>"},
{"lineNum":"  276","line":"    {"},
{"lineNum":"  277","line":"      template <typename _Tp, typename _Up>"},
{"lineNum":"  278","line":"\t_GLIBCXX14_CONSTEXPR"},
{"lineNum":"  279","line":"\tauto"},
{"lineNum":"  280","line":"\toperator()(_Tp&& __t, _Up&& __u) const"},
{"lineNum":"  281","line":"\tnoexcept(noexcept(std::forward<_Tp>(__t) / std::forward<_Up>(__u)))"},
{"lineNum":"  282","line":"\t-> decltype(std::forward<_Tp>(__t) / std::forward<_Up>(__u))"},
{"lineNum":"  283","line":"\t{ return std::forward<_Tp>(__t) / std::forward<_Up>(__u); }"},
{"lineNum":"  284","line":""},
{"lineNum":"  285","line":"      typedef __is_transparent is_transparent;"},
{"lineNum":"  286","line":"    };"},
{"lineNum":"  287","line":""},
{"lineNum":"  288","line":"  /// One of the @link arithmetic_functors math functors@endlink."},
{"lineNum":"  289","line":"  template<>"},
{"lineNum":"  290","line":"    struct modulus<void>"},
{"lineNum":"  291","line":"    {"},
{"lineNum":"  292","line":"      template <typename _Tp, typename _Up>"},
{"lineNum":"  293","line":"\t_GLIBCXX14_CONSTEXPR"},
{"lineNum":"  294","line":"\tauto"},
{"lineNum":"  295","line":"\toperator()(_Tp&& __t, _Up&& __u) const"},
{"lineNum":"  296","line":"\tnoexcept(noexcept(std::forward<_Tp>(__t) % std::forward<_Up>(__u)))"},
{"lineNum":"  297","line":"\t-> decltype(std::forward<_Tp>(__t) % std::forward<_Up>(__u))"},
{"lineNum":"  298","line":"\t{ return std::forward<_Tp>(__t) % std::forward<_Up>(__u); }"},
{"lineNum":"  299","line":""},
{"lineNum":"  300","line":"      typedef __is_transparent is_transparent;"},
{"lineNum":"  301","line":"    };"},
{"lineNum":"  302","line":""},
{"lineNum":"  303","line":"  /// One of the @link arithmetic_functors math functors@endlink."},
{"lineNum":"  304","line":"  template<>"},
{"lineNum":"  305","line":"    struct negate<void>"},
{"lineNum":"  306","line":"    {"},
{"lineNum":"  307","line":"      template <typename _Tp>"},
{"lineNum":"  308","line":"\t_GLIBCXX14_CONSTEXPR"},
{"lineNum":"  309","line":"\tauto"},
{"lineNum":"  310","line":"\toperator()(_Tp&& __t) const"},
{"lineNum":"  311","line":"\tnoexcept(noexcept(-std::forward<_Tp>(__t)))"},
{"lineNum":"  312","line":"\t-> decltype(-std::forward<_Tp>(__t))"},
{"lineNum":"  313","line":"\t{ return -std::forward<_Tp>(__t); }"},
{"lineNum":"  314","line":""},
{"lineNum":"  315","line":"      typedef __is_transparent is_transparent;"},
{"lineNum":"  316","line":"    };"},
{"lineNum":"  317","line":"#endif"},
{"lineNum":"  318","line":"  /** @}  */"},
{"lineNum":"  319","line":""},
{"lineNum":"  320","line":"  // 20.3.3 comparisons"},
{"lineNum":"  321","line":"  /** @defgroup comparison_functors Comparison Classes"},
{"lineNum":"  322","line":"   * @ingroup functors"},
{"lineNum":"  323","line":"   *"},
{"lineNum":"  324","line":"   *  The library provides six wrapper functors for all the basic comparisons"},
{"lineNum":"  325","line":"   *  in C++, like @c <."},
{"lineNum":"  326","line":"   *"},
{"lineNum":"  327","line":"   *  @{"},
{"lineNum":"  328","line":"   */"},
{"lineNum":"  329","line":"#if __cplusplus > 201103L"},
{"lineNum":"  330","line":"  template<typename _Tp = void>"},
{"lineNum":"  331","line":"    struct equal_to;"},
{"lineNum":"  332","line":""},
{"lineNum":"  333","line":"  template<typename _Tp = void>"},
{"lineNum":"  334","line":"    struct not_equal_to;"},
{"lineNum":"  335","line":""},
{"lineNum":"  336","line":"  template<typename _Tp = void>"},
{"lineNum":"  337","line":"    struct greater;"},
{"lineNum":"  338","line":""},
{"lineNum":"  339","line":"  template<typename _Tp = void>"},
{"lineNum":"  340","line":"    struct less;"},
{"lineNum":"  341","line":""},
{"lineNum":"  342","line":"  template<typename _Tp = void>"},
{"lineNum":"  343","line":"    struct greater_equal;"},
{"lineNum":"  344","line":""},
{"lineNum":"  345","line":"  template<typename _Tp = void>"},
{"lineNum":"  346","line":"    struct less_equal;"},
{"lineNum":"  347","line":"#endif"},
{"lineNum":"  348","line":""},
{"lineNum":"  349","line":"  /// One of the @link comparison_functors comparison functors@endlink."},
{"lineNum":"  350","line":"  template<typename _Tp>"},
{"lineNum":"  351","line":"    struct equal_to : public binary_function<_Tp, _Tp, bool>"},
{"lineNum":"  352","line":"    {"},
{"lineNum":"  353","line":"      _GLIBCXX14_CONSTEXPR"},
{"lineNum":"  354","line":"      bool"},
{"lineNum":"  355","line":"      operator()(const _Tp& __x, const _Tp& __y) const"},
{"lineNum":"  356","line":"      { return __x == __y; }"},
{"lineNum":"  357","line":"    };"},
{"lineNum":"  358","line":""},
{"lineNum":"  359","line":"  /// One of the @link comparison_functors comparison functors@endlink."},
{"lineNum":"  360","line":"  template<typename _Tp>"},
{"lineNum":"  361","line":"    struct not_equal_to : public binary_function<_Tp, _Tp, bool>"},
{"lineNum":"  362","line":"    {"},
{"lineNum":"  363","line":"      _GLIBCXX14_CONSTEXPR"},
{"lineNum":"  364","line":"      bool"},
{"lineNum":"  365","line":"      operator()(const _Tp& __x, const _Tp& __y) const"},
{"lineNum":"  366","line":"      { return __x != __y; }"},
{"lineNum":"  367","line":"    };"},
{"lineNum":"  368","line":""},
{"lineNum":"  369","line":"  /// One of the @link comparison_functors comparison functors@endlink."},
{"lineNum":"  370","line":"  template<typename _Tp>"},
{"lineNum":"  371","line":"    struct greater : public binary_function<_Tp, _Tp, bool>"},
{"lineNum":"  372","line":"    {"},
{"lineNum":"  373","line":"      _GLIBCXX14_CONSTEXPR"},
{"lineNum":"  374","line":"      bool"},
{"lineNum":"  375","line":"      operator()(const _Tp& __x, const _Tp& __y) const"},
{"lineNum":"  376","line":"      { return __x > __y; }"},
{"lineNum":"  377","line":"    };"},
{"lineNum":"  378","line":""},
{"lineNum":"  379","line":"  /// One of the @link comparison_functors comparison functors@endlink."},
{"lineNum":"  380","line":"  template<typename _Tp>"},
{"lineNum":"  381","line":"    struct less : public binary_function<_Tp, _Tp, bool>"},
{"lineNum":"  382","line":"    {"},
{"lineNum":"  383","line":"      _GLIBCXX14_CONSTEXPR"},
{"lineNum":"  384","line":"      bool"},
{"lineNum":"  385","line":"      operator()(const _Tp& __x, const _Tp& __y) const","class":"lineCov","hits":"1","order":"1048","possible_hits":"1",},
{"lineNum":"  386","line":"      { return __x < __y; }","class":"linePartCov","hits":"1","order":"1049","possible_hits":"2",},
{"lineNum":"  387","line":"    };"},
{"lineNum":"  388","line":""},
{"lineNum":"  389","line":"  /// One of the @link comparison_functors comparison functors@endlink."},
{"lineNum":"  390","line":"  template<typename _Tp>"},
{"lineNum":"  391","line":"    struct greater_equal : public binary_function<_Tp, _Tp, bool>"},
{"lineNum":"  392","line":"    {"},
{"lineNum":"  393","line":"      _GLIBCXX14_CONSTEXPR"},
{"lineNum":"  394","line":"      bool"},
{"lineNum":"  395","line":"      operator()(const _Tp& __x, const _Tp& __y) const"},
{"lineNum":"  396","line":"      { return __x >= __y; }"},
{"lineNum":"  397","line":"    };"},
{"lineNum":"  398","line":""},
{"lineNum":"  399","line":"  /// One of the @link comparison_functors comparison functors@endlink."},
{"lineNum":"  400","line":"  template<typename _Tp>"},
{"lineNum":"  401","line":"    struct less_equal : public binary_function<_Tp, _Tp, bool>"},
{"lineNum":"  402","line":"    {"},
{"lineNum":"  403","line":"      _GLIBCXX14_CONSTEXPR"},
{"lineNum":"  404","line":"      bool"},
{"lineNum":"  405","line":"      operator()(const _Tp& __x, const _Tp& __y) const"},
{"lineNum":"  406","line":"      { return __x <= __y; }"},
{"lineNum":"  407","line":"    };"},
{"lineNum":"  408","line":""},
{"lineNum":"  409","line":"#if __cplusplus > 201103L"},
{"lineNum":"  410","line":"  /// One of the @link comparison_functors comparison functors@endlink."},
{"lineNum":"  411","line":"  template<>"},
{"lineNum":"  412","line":"    struct equal_to<void>"},
{"lineNum":"  413","line":"    {"},
{"lineNum":"  414","line":"      template <typename _Tp, typename _Up>"},
{"lineNum":"  415","line":"\t_GLIBCXX14_CONSTEXPR"},
{"lineNum":"  416","line":"\tauto"},
{"lineNum":"  417","line":"\toperator()(_Tp&& __t, _Up&& __u) const"},
{"lineNum":"  418","line":"\tnoexcept(noexcept(std::forward<_Tp>(__t) == std::forward<_Up>(__u)))"},
{"lineNum":"  419","line":"\t-> decltype(std::forward<_Tp>(__t) == std::forward<_Up>(__u))"},
{"lineNum":"  420","line":"\t{ return std::forward<_Tp>(__t) == std::forward<_Up>(__u); }"},
{"lineNum":"  421","line":""},
{"lineNum":"  422","line":"      typedef __is_transparent is_transparent;"},
{"lineNum":"  423","line":"    };"},
{"lineNum":"  424","line":""},
{"lineNum":"  425","line":"  /// One of the @link comparison_functors comparison functors@endlink."},
{"lineNum":"  426","line":"  template<>"},
{"lineNum":"  427","line":"    struct not_equal_to<void>"},
{"lineNum":"  428","line":"    {"},
{"lineNum":"  429","line":"      template <typename _Tp, typename _Up>"},
{"lineNum":"  430","line":"\t_GLIBCXX14_CONSTEXPR"},
{"lineNum":"  431","line":"\tauto"},
{"lineNum":"  432","line":"\toperator()(_Tp&& __t, _Up&& __u) const"},
{"lineNum":"  433","line":"\tnoexcept(noexcept(std::forward<_Tp>(__t) != std::forward<_Up>(__u)))"},
{"lineNum":"  434","line":"\t-> decltype(std::forward<_Tp>(__t) != std::forward<_Up>(__u))"},
{"lineNum":"  435","line":"\t{ return std::forward<_Tp>(__t) != std::forward<_Up>(__u); }"},
{"lineNum":"  436","line":""},
{"lineNum":"  437","line":"      typedef __is_transparent is_transparent;"},
{"lineNum":"  438","line":"    };"},
{"lineNum":"  439","line":""},
{"lineNum":"  440","line":"  /// One of the @link comparison_functors comparison functors@endlink."},
{"lineNum":"  441","line":"  template<>"},
{"lineNum":"  442","line":"    struct greater<void>"},
{"lineNum":"  443","line":"    {"},
{"lineNum":"  444","line":"      template <typename _Tp, typename _Up>"},
{"lineNum":"  445","line":"\t_GLIBCXX14_CONSTEXPR"},
{"lineNum":"  446","line":"\tauto"},
{"lineNum":"  447","line":"\toperator()(_Tp&& __t, _Up&& __u) const"},
{"lineNum":"  448","line":"\tnoexcept(noexcept(std::forward<_Tp>(__t) > std::forward<_Up>(__u)))"},
{"lineNum":"  449","line":"\t-> decltype(std::forward<_Tp>(__t) > std::forward<_Up>(__u))"},
{"lineNum":"  450","line":"\t{ return std::forward<_Tp>(__t) > std::forward<_Up>(__u); }"},
{"lineNum":"  451","line":""},
{"lineNum":"  452","line":"      typedef __is_transparent is_transparent;"},
{"lineNum":"  453","line":"    };"},
{"lineNum":"  454","line":""},
{"lineNum":"  455","line":"  /// One of the @link comparison_functors comparison functors@endlink."},
{"lineNum":"  456","line":"  template<>"},
{"lineNum":"  457","line":"    struct less<void>"},
{"lineNum":"  458","line":"    {"},
{"lineNum":"  459","line":"      template <typename _Tp, typename _Up>"},
{"lineNum":"  460","line":"\t_GLIBCXX14_CONSTEXPR"},
{"lineNum":"  461","line":"\tauto"},
{"lineNum":"  462","line":"\toperator()(_Tp&& __t, _Up&& __u) const"},
{"lineNum":"  463","line":"\tnoexcept(noexcept(std::forward<_Tp>(__t) < std::forward<_Up>(__u)))"},
{"lineNum":"  464","line":"\t-> decltype(std::forward<_Tp>(__t) < std::forward<_Up>(__u))"},
{"lineNum":"  465","line":"\t{ return std::forward<_Tp>(__t) < std::forward<_Up>(__u); }"},
{"lineNum":"  466","line":""},
{"lineNum":"  467","line":"      typedef __is_transparent is_transparent;"},
{"lineNum":"  468","line":"    };"},
{"lineNum":"  469","line":""},
{"lineNum":"  470","line":"  /// One of the @link comparison_functors comparison functors@endlink."},
{"lineNum":"  471","line":"  template<>"},
{"lineNum":"  472","line":"    struct greater_equal<void>"},
{"lineNum":"  473","line":"    {"},
{"lineNum":"  474","line":"      template <typename _Tp, typename _Up>"},
{"lineNum":"  475","line":"\t_GLIBCXX14_CONSTEXPR"},
{"lineNum":"  476","line":"\tauto"},
{"lineNum":"  477","line":"\toperator()(_Tp&& __t, _Up&& __u) const"},
{"lineNum":"  478","line":"\tnoexcept(noexcept(std::forward<_Tp>(__t) >= std::forward<_Up>(__u)))"},
{"lineNum":"  479","line":"\t-> decltype(std::forward<_Tp>(__t) >= std::forward<_Up>(__u))"},
{"lineNum":"  480","line":"\t{ return std::forward<_Tp>(__t) >= std::forward<_Up>(__u); }"},
{"lineNum":"  481","line":""},
{"lineNum":"  482","line":"      typedef __is_transparent is_transparent;"},
{"lineNum":"  483","line":"    };"},
{"lineNum":"  484","line":""},
{"lineNum":"  485","line":"  /// One of the @link comparison_functors comparison functors@endlink."},
{"lineNum":"  486","line":"  template<>"},
{"lineNum":"  487","line":"    struct less_equal<void>"},
{"lineNum":"  488","line":"    {"},
{"lineNum":"  489","line":"      template <typename _Tp, typename _Up>"},
{"lineNum":"  490","line":"\t_GLIBCXX14_CONSTEXPR"},
{"lineNum":"  491","line":"\tauto"},
{"lineNum":"  492","line":"\toperator()(_Tp&& __t, _Up&& __u) const"},
{"lineNum":"  493","line":"\tnoexcept(noexcept(std::forward<_Tp>(__t) <= std::forward<_Up>(__u)))"},
{"lineNum":"  494","line":"\t-> decltype(std::forward<_Tp>(__t) <= std::forward<_Up>(__u))"},
{"lineNum":"  495","line":"\t{ return std::forward<_Tp>(__t) <= std::forward<_Up>(__u); }"},
{"lineNum":"  496","line":""},
{"lineNum":"  497","line":"      typedef __is_transparent is_transparent;"},
{"lineNum":"  498","line":"    };"},
{"lineNum":"  499","line":"#endif"},
{"lineNum":"  500","line":"  /** @}  */"},
{"lineNum":"  501","line":""},
{"lineNum":"  502","line":"  // 20.3.4 logical operations"},
{"lineNum":"  503","line":"  /** @defgroup logical_functors Boolean Operations Classes"},
{"lineNum":"  504","line":"   * @ingroup functors"},
{"lineNum":"  505","line":"   *"},
{"lineNum":"  506","line":"   *  Here are wrapper functors for Boolean operations: @c &&, @c ||,"},
{"lineNum":"  507","line":"   *  and @c !."},
{"lineNum":"  508","line":"   *"},
{"lineNum":"  509","line":"   *  @{"},
{"lineNum":"  510","line":"   */"},
{"lineNum":"  511","line":"#if __cplusplus > 201103L"},
{"lineNum":"  512","line":"  template<typename _Tp = void>"},
{"lineNum":"  513","line":"    struct logical_and;"},
{"lineNum":"  514","line":""},
{"lineNum":"  515","line":"  template<typename _Tp = void>"},
{"lineNum":"  516","line":"    struct logical_or;"},
{"lineNum":"  517","line":""},
{"lineNum":"  518","line":"  template<typename _Tp = void>"},
{"lineNum":"  519","line":"    struct logical_not;"},
{"lineNum":"  520","line":"#endif"},
{"lineNum":"  521","line":""},
{"lineNum":"  522","line":"  /// One of the @link logical_functors Boolean operations functors@endlink."},
{"lineNum":"  523","line":"  template<typename _Tp>"},
{"lineNum":"  524","line":"    struct logical_and : public binary_function<_Tp, _Tp, bool>"},
{"lineNum":"  525","line":"    {"},
{"lineNum":"  526","line":"      _GLIBCXX14_CONSTEXPR"},
{"lineNum":"  527","line":"      bool"},
{"lineNum":"  528","line":"      operator()(const _Tp& __x, const _Tp& __y) const"},
{"lineNum":"  529","line":"      { return __x && __y; }"},
{"lineNum":"  530","line":"    };"},
{"lineNum":"  531","line":""},
{"lineNum":"  532","line":"  /// One of the @link logical_functors Boolean operations functors@endlink."},
{"lineNum":"  533","line":"  template<typename _Tp>"},
{"lineNum":"  534","line":"    struct logical_or : public binary_function<_Tp, _Tp, bool>"},
{"lineNum":"  535","line":"    {"},
{"lineNum":"  536","line":"      _GLIBCXX14_CONSTEXPR"},
{"lineNum":"  537","line":"      bool"},
{"lineNum":"  538","line":"      operator()(const _Tp& __x, const _Tp& __y) const"},
{"lineNum":"  539","line":"      { return __x || __y; }"},
{"lineNum":"  540","line":"    };"},
{"lineNum":"  541","line":""},
{"lineNum":"  542","line":"  /// One of the @link logical_functors Boolean operations functors@endlink."},
{"lineNum":"  543","line":"  template<typename _Tp>"},
{"lineNum":"  544","line":"    struct logical_not : public unary_function<_Tp, bool>"},
{"lineNum":"  545","line":"    {"},
{"lineNum":"  546","line":"      _GLIBCXX14_CONSTEXPR"},
{"lineNum":"  547","line":"      bool"},
{"lineNum":"  548","line":"      operator()(const _Tp& __x) const"},
{"lineNum":"  549","line":"      { return !__x; }"},
{"lineNum":"  550","line":"    };"},
{"lineNum":"  551","line":""},
{"lineNum":"  552","line":"#if __cplusplus > 201103L"},
{"lineNum":"  553","line":"  /// One of the @link logical_functors Boolean operations functors@endlink."},
{"lineNum":"  554","line":"  template<>"},
{"lineNum":"  555","line":"    struct logical_and<void>"},
{"lineNum":"  556","line":"    {"},
{"lineNum":"  557","line":"      template <typename _Tp, typename _Up>"},
{"lineNum":"  558","line":"\t_GLIBCXX14_CONSTEXPR"},
{"lineNum":"  559","line":"\tauto"},
{"lineNum":"  560","line":"\toperator()(_Tp&& __t, _Up&& __u) const"},
{"lineNum":"  561","line":"\tnoexcept(noexcept(std::forward<_Tp>(__t) && std::forward<_Up>(__u)))"},
{"lineNum":"  562","line":"\t-> decltype(std::forward<_Tp>(__t) && std::forward<_Up>(__u))"},
{"lineNum":"  563","line":"\t{ return std::forward<_Tp>(__t) && std::forward<_Up>(__u); }"},
{"lineNum":"  564","line":""},
{"lineNum":"  565","line":"      typedef __is_transparent is_transparent;"},
{"lineNum":"  566","line":"    };"},
{"lineNum":"  567","line":""},
{"lineNum":"  568","line":"  /// One of the @link logical_functors Boolean operations functors@endlink."},
{"lineNum":"  569","line":"  template<>"},
{"lineNum":"  570","line":"    struct logical_or<void>"},
{"lineNum":"  571","line":"    {"},
{"lineNum":"  572","line":"      template <typename _Tp, typename _Up>"},
{"lineNum":"  573","line":"\t_GLIBCXX14_CONSTEXPR"},
{"lineNum":"  574","line":"\tauto"},
{"lineNum":"  575","line":"\toperator()(_Tp&& __t, _Up&& __u) const"},
{"lineNum":"  576","line":"\tnoexcept(noexcept(std::forward<_Tp>(__t) || std::forward<_Up>(__u)))"},
{"lineNum":"  577","line":"\t-> decltype(std::forward<_Tp>(__t) || std::forward<_Up>(__u))"},
{"lineNum":"  578","line":"\t{ return std::forward<_Tp>(__t) || std::forward<_Up>(__u); }"},
{"lineNum":"  579","line":""},
{"lineNum":"  580","line":"      typedef __is_transparent is_transparent;"},
{"lineNum":"  581","line":"    };"},
{"lineNum":"  582","line":""},
{"lineNum":"  583","line":"  /// One of the @link logical_functors Boolean operations functors@endlink."},
{"lineNum":"  584","line":"  template<>"},
{"lineNum":"  585","line":"    struct logical_not<void>"},
{"lineNum":"  586","line":"    {"},
{"lineNum":"  587","line":"      template <typename _Tp>"},
{"lineNum":"  588","line":"\t_GLIBCXX14_CONSTEXPR"},
{"lineNum":"  589","line":"\tauto"},
{"lineNum":"  590","line":"\toperator()(_Tp&& __t) const"},
{"lineNum":"  591","line":"\tnoexcept(noexcept(!std::forward<_Tp>(__t)))"},
{"lineNum":"  592","line":"\t-> decltype(!std::forward<_Tp>(__t))"},
{"lineNum":"  593","line":"\t{ return !std::forward<_Tp>(__t); }"},
{"lineNum":"  594","line":""},
{"lineNum":"  595","line":"      typedef __is_transparent is_transparent;"},
{"lineNum":"  596","line":"    };"},
{"lineNum":"  597","line":"#endif"},
{"lineNum":"  598","line":"  /** @}  */"},
{"lineNum":"  599","line":""},
{"lineNum":"  600","line":"#if __cplusplus > 201103L"},
{"lineNum":"  601","line":"  template<typename _Tp = void>"},
{"lineNum":"  602","line":"    struct bit_and;"},
{"lineNum":"  603","line":""},
{"lineNum":"  604","line":"  template<typename _Tp = void>"},
{"lineNum":"  605","line":"    struct bit_or;"},
{"lineNum":"  606","line":""},
{"lineNum":"  607","line":"  template<typename _Tp = void>"},
{"lineNum":"  608","line":"    struct bit_xor;"},
{"lineNum":"  609","line":""},
{"lineNum":"  610","line":"  template<typename _Tp = void>"},
{"lineNum":"  611","line":"    struct bit_not;"},
{"lineNum":"  612","line":"#endif"},
{"lineNum":"  613","line":""},
{"lineNum":"  614","line":"  // _GLIBCXX_RESOLVE_LIB_DEFECTS"},
{"lineNum":"  615","line":"  // DR 660. Missing Bitwise Operations."},
{"lineNum":"  616","line":"  template<typename _Tp>"},
{"lineNum":"  617","line":"    struct bit_and : public binary_function<_Tp, _Tp, _Tp>"},
{"lineNum":"  618","line":"    {"},
{"lineNum":"  619","line":"      _GLIBCXX14_CONSTEXPR"},
{"lineNum":"  620","line":"      _Tp"},
{"lineNum":"  621","line":"      operator()(const _Tp& __x, const _Tp& __y) const"},
{"lineNum":"  622","line":"      { return __x & __y; }"},
{"lineNum":"  623","line":"    };"},
{"lineNum":"  624","line":""},
{"lineNum":"  625","line":"  template<typename _Tp>"},
{"lineNum":"  626","line":"    struct bit_or : public binary_function<_Tp, _Tp, _Tp>"},
{"lineNum":"  627","line":"    {"},
{"lineNum":"  628","line":"      _GLIBCXX14_CONSTEXPR"},
{"lineNum":"  629","line":"      _Tp"},
{"lineNum":"  630","line":"      operator()(const _Tp& __x, const _Tp& __y) const"},
{"lineNum":"  631","line":"      { return __x | __y; }"},
{"lineNum":"  632","line":"    };"},
{"lineNum":"  633","line":""},
{"lineNum":"  634","line":"  template<typename _Tp>"},
{"lineNum":"  635","line":"    struct bit_xor : public binary_function<_Tp, _Tp, _Tp>"},
{"lineNum":"  636","line":"    {"},
{"lineNum":"  637","line":"      _GLIBCXX14_CONSTEXPR"},
{"lineNum":"  638","line":"      _Tp"},
{"lineNum":"  639","line":"      operator()(const _Tp& __x, const _Tp& __y) const"},
{"lineNum":"  640","line":"      { return __x ^ __y; }"},
{"lineNum":"  641","line":"    };"},
{"lineNum":"  642","line":""},
{"lineNum":"  643","line":"  template<typename _Tp>"},
{"lineNum":"  644","line":"    struct bit_not : public unary_function<_Tp, _Tp>"},
{"lineNum":"  645","line":"    {"},
{"lineNum":"  646","line":"    _GLIBCXX14_CONSTEXPR"},
{"lineNum":"  647","line":"      _Tp"},
{"lineNum":"  648","line":"      operator()(const _Tp& __x) const"},
{"lineNum":"  649","line":"      { return ~__x; }"},
{"lineNum":"  650","line":"    };"},
{"lineNum":"  651","line":""},
{"lineNum":"  652","line":"#if __cplusplus > 201103L"},
{"lineNum":"  653","line":"  template <>"},
{"lineNum":"  654","line":"    struct bit_and<void>"},
{"lineNum":"  655","line":"    {"},
{"lineNum":"  656","line":"      template <typename _Tp, typename _Up>"},
{"lineNum":"  657","line":"\t_GLIBCXX14_CONSTEXPR"},
{"lineNum":"  658","line":"\tauto"},
{"lineNum":"  659","line":"\toperator()(_Tp&& __t, _Up&& __u) const"},
{"lineNum":"  660","line":"\tnoexcept(noexcept(std::forward<_Tp>(__t) & std::forward<_Up>(__u)))"},
{"lineNum":"  661","line":"\t-> decltype(std::forward<_Tp>(__t) & std::forward<_Up>(__u))"},
{"lineNum":"  662","line":"\t{ return std::forward<_Tp>(__t) & std::forward<_Up>(__u); }"},
{"lineNum":"  663","line":""},
{"lineNum":"  664","line":"      typedef __is_transparent is_transparent;"},
{"lineNum":"  665","line":"    };"},
{"lineNum":"  666","line":""},
{"lineNum":"  667","line":"  template <>"},
{"lineNum":"  668","line":"    struct bit_or<void>"},
{"lineNum":"  669","line":"    {"},
{"lineNum":"  670","line":"      template <typename _Tp, typename _Up>"},
{"lineNum":"  671","line":"\t_GLIBCXX14_CONSTEXPR"},
{"lineNum":"  672","line":"\tauto"},
{"lineNum":"  673","line":"\toperator()(_Tp&& __t, _Up&& __u) const"},
{"lineNum":"  674","line":"\tnoexcept(noexcept(std::forward<_Tp>(__t) | std::forward<_Up>(__u)))"},
{"lineNum":"  675","line":"\t-> decltype(std::forward<_Tp>(__t) | std::forward<_Up>(__u))"},
{"lineNum":"  676","line":"\t{ return std::forward<_Tp>(__t) | std::forward<_Up>(__u); }"},
{"lineNum":"  677","line":""},
{"lineNum":"  678","line":"      typedef __is_transparent is_transparent;"},
{"lineNum":"  679","line":"    };"},
{"lineNum":"  680","line":""},
{"lineNum":"  681","line":"  template <>"},
{"lineNum":"  682","line":"    struct bit_xor<void>"},
{"lineNum":"  683","line":"    {"},
{"lineNum":"  684","line":"      template <typename _Tp, typename _Up>"},
{"lineNum":"  685","line":"\t_GLIBCXX14_CONSTEXPR"},
{"lineNum":"  686","line":"\tauto"},
{"lineNum":"  687","line":"\toperator()(_Tp&& __t, _Up&& __u) const"},
{"lineNum":"  688","line":"\tnoexcept(noexcept(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u)))"},
{"lineNum":"  689","line":"\t-> decltype(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u))"},
{"lineNum":"  690","line":"\t{ return std::forward<_Tp>(__t) ^ std::forward<_Up>(__u); }"},
{"lineNum":"  691","line":""},
{"lineNum":"  692","line":"      typedef __is_transparent is_transparent;"},
{"lineNum":"  693","line":"    };"},
{"lineNum":"  694","line":""},
{"lineNum":"  695","line":"  template <>"},
{"lineNum":"  696","line":"    struct bit_not<void>"},
{"lineNum":"  697","line":"    {"},
{"lineNum":"  698","line":"      template <typename _Tp>"},
{"lineNum":"  699","line":"\t_GLIBCXX14_CONSTEXPR"},
{"lineNum":"  700","line":"\tauto"},
{"lineNum":"  701","line":"\toperator()(_Tp&& __t) const"},
{"lineNum":"  702","line":"\tnoexcept(noexcept(~std::forward<_Tp>(__t)))"},
{"lineNum":"  703","line":"\t-> decltype(~std::forward<_Tp>(__t))"},
{"lineNum":"  704","line":"\t{ return ~std::forward<_Tp>(__t); }"},
{"lineNum":"  705","line":""},
{"lineNum":"  706","line":"      typedef __is_transparent is_transparent;"},
{"lineNum":"  707","line":"    };"},
{"lineNum":"  708","line":"#endif"},
{"lineNum":"  709","line":""},
{"lineNum":"  710","line":"  // 20.3.5 negators"},
{"lineNum":"  711","line":"  /** @defgroup negators Negators"},
{"lineNum":"  712","line":"   * @ingroup functors"},
{"lineNum":"  713","line":"   *"},
{"lineNum":"  714","line":"   *  The functions @c not1 and @c not2 each take a predicate functor"},
{"lineNum":"  715","line":"   *  and return an instance of @c unary_negate or"},
{"lineNum":"  716","line":"   *  @c binary_negate, respectively.  These classes are functors whose"},
{"lineNum":"  717","line":"   *  @c operator() performs the stored predicate function and then returns"},
{"lineNum":"  718","line":"   *  the negation of the result."},
{"lineNum":"  719","line":"   *"},
{"lineNum":"  720","line":"   *  For example, given a vector of integers and a trivial predicate,"},
{"lineNum":"  721","line":"   *  \\code"},
{"lineNum":"  722","line":"   *  struct IntGreaterThanThree"},
{"lineNum":"  723","line":"   *    : public std::unary_function<int, bool>"},
{"lineNum":"  724","line":"   *  {"},
{"lineNum":"  725","line":"   *      bool operator() (int x) { return x > 3; }"},
{"lineNum":"  726","line":"   *  };"},
{"lineNum":"  727","line":"   *"},
{"lineNum":"  728","line":"   *  std::find_if (v.begin(), v.end(), not1(IntGreaterThanThree()));"},
{"lineNum":"  729","line":"   *  \\endcode"},
{"lineNum":"  730","line":"   *  The call to @c find_if will locate the first index (i) of @c v for which"},
{"lineNum":"  731","line":"   *  <code>!(v[i] > 3)</code> is true."},
{"lineNum":"  732","line":"   *"},
{"lineNum":"  733","line":"   *  The not1/unary_negate combination works on predicates taking a single"},
{"lineNum":"  734","line":"   *  argument.  The not2/binary_negate combination works on predicates which"},
{"lineNum":"  735","line":"   *  take two arguments."},
{"lineNum":"  736","line":"   *"},
{"lineNum":"  737","line":"   *  @{"},
{"lineNum":"  738","line":"   */"},
{"lineNum":"  739","line":"  /// One of the @link negators negation functors@endlink."},
{"lineNum":"  740","line":"  template<typename _Predicate>"},
{"lineNum":"  741","line":"    class unary_negate"},
{"lineNum":"  742","line":"    : public unary_function<typename _Predicate::argument_type, bool>"},
{"lineNum":"  743","line":"    {"},
{"lineNum":"  744","line":"    protected:"},
{"lineNum":"  745","line":"      _Predicate _M_pred;"},
{"lineNum":"  746","line":""},
{"lineNum":"  747","line":"    public:"},
{"lineNum":"  748","line":"      _GLIBCXX14_CONSTEXPR"},
{"lineNum":"  749","line":"      explicit"},
{"lineNum":"  750","line":"      unary_negate(const _Predicate& __x) : _M_pred(__x) { }"},
{"lineNum":"  751","line":""},
{"lineNum":"  752","line":"      _GLIBCXX14_CONSTEXPR"},
{"lineNum":"  753","line":"      bool"},
{"lineNum":"  754","line":"      operator()(const typename _Predicate::argument_type& __x) const"},
{"lineNum":"  755","line":"      { return !_M_pred(__x); }"},
{"lineNum":"  756","line":"    };"},
{"lineNum":"  757","line":""},
{"lineNum":"  758","line":"  /// One of the @link negators negation functors@endlink."},
{"lineNum":"  759","line":"  template<typename _Predicate>"},
{"lineNum":"  760","line":"    _GLIBCXX14_CONSTEXPR"},
{"lineNum":"  761","line":"    inline unary_negate<_Predicate>"},
{"lineNum":"  762","line":"    not1(const _Predicate& __pred)"},
{"lineNum":"  763","line":"    { return unary_negate<_Predicate>(__pred); }"},
{"lineNum":"  764","line":""},
{"lineNum":"  765","line":"  /// One of the @link negators negation functors@endlink."},
{"lineNum":"  766","line":"  template<typename _Predicate>"},
{"lineNum":"  767","line":"    class binary_negate"},
{"lineNum":"  768","line":"    : public binary_function<typename _Predicate::first_argument_type,"},
{"lineNum":"  769","line":"\t\t\t     typename _Predicate::second_argument_type, bool>"},
{"lineNum":"  770","line":"    {"},
{"lineNum":"  771","line":"    protected:"},
{"lineNum":"  772","line":"      _Predicate _M_pred;"},
{"lineNum":"  773","line":""},
{"lineNum":"  774","line":"    public:"},
{"lineNum":"  775","line":"      _GLIBCXX14_CONSTEXPR"},
{"lineNum":"  776","line":"      explicit"},
{"lineNum":"  777","line":"      binary_negate(const _Predicate& __x) : _M_pred(__x) { }"},
{"lineNum":"  778","line":""},
{"lineNum":"  779","line":"      _GLIBCXX14_CONSTEXPR"},
{"lineNum":"  780","line":"      bool"},
{"lineNum":"  781","line":"      operator()(const typename _Predicate::first_argument_type& __x,"},
{"lineNum":"  782","line":"\t\t const typename _Predicate::second_argument_type& __y) const"},
{"lineNum":"  783","line":"      { return !_M_pred(__x, __y); }"},
{"lineNum":"  784","line":"    };"},
{"lineNum":"  785","line":""},
{"lineNum":"  786","line":"  /// One of the @link negators negation functors@endlink."},
{"lineNum":"  787","line":"  template<typename _Predicate>"},
{"lineNum":"  788","line":"    _GLIBCXX14_CONSTEXPR"},
{"lineNum":"  789","line":"    inline binary_negate<_Predicate>"},
{"lineNum":"  790","line":"    not2(const _Predicate& __pred)"},
{"lineNum":"  791","line":"    { return binary_negate<_Predicate>(__pred); }"},
{"lineNum":"  792","line":"  /** @}  */"},
{"lineNum":"  793","line":""},
{"lineNum":"  794","line":"  // 20.3.7 adaptors pointers functions"},
{"lineNum":"  795","line":"  /** @defgroup pointer_adaptors Adaptors for pointers to functions"},
{"lineNum":"  796","line":"   * @ingroup functors"},
{"lineNum":"  797","line":"   *"},
{"lineNum":"  798","line":"   *  The advantage of function objects over pointers to functions is that"},
{"lineNum":"  799","line":"   *  the objects in the standard library declare nested typedefs describing"},
{"lineNum":"  800","line":"   *  their argument and result types with uniform names (e.g., @c result_type"},
{"lineNum":"  801","line":"   *  from the base classes @c unary_function and @c binary_function)."},
{"lineNum":"  802","line":"   *  Sometimes those typedefs are required, not just optional."},
{"lineNum":"  803","line":"   *"},
{"lineNum":"  804","line":"   *  Adaptors are provided to turn pointers to unary (single-argument) and"},
{"lineNum":"  805","line":"   *  binary (double-argument) functions into function objects.  The"},
{"lineNum":"  806","line":"   *  long-winded functor @c pointer_to_unary_function is constructed with a"},
{"lineNum":"  807","line":"   *  function pointer @c f, and its @c operator() called with argument @c x"},
{"lineNum":"  808","line":"   *  returns @c f(x).  The functor @c pointer_to_binary_function does the same"},
{"lineNum":"  809","line":"   *  thing, but with a double-argument @c f and @c operator()."},
{"lineNum":"  810","line":"   *"},
{"lineNum":"  811","line":"   *  The function @c ptr_fun takes a pointer-to-function @c f and constructs"},
{"lineNum":"  812","line":"   *  an instance of the appropriate functor."},
{"lineNum":"  813","line":"   *"},
{"lineNum":"  814","line":"   *  @{"},
{"lineNum":"  815","line":"   */"},
{"lineNum":"  816","line":"  /// One of the @link pointer_adaptors adaptors for function pointers@endlink."},
{"lineNum":"  817","line":"  template<typename _Arg, typename _Result>"},
{"lineNum":"  818","line":"    class pointer_to_unary_function : public unary_function<_Arg, _Result>"},
{"lineNum":"  819","line":"    {"},
{"lineNum":"  820","line":"    protected:"},
{"lineNum":"  821","line":"      _Result (*_M_ptr)(_Arg);"},
{"lineNum":"  822","line":""},
{"lineNum":"  823","line":"    public:"},
{"lineNum":"  824","line":"      pointer_to_unary_function() { }"},
{"lineNum":"  825","line":""},
{"lineNum":"  826","line":"      explicit"},
{"lineNum":"  827","line":"      pointer_to_unary_function(_Result (*__x)(_Arg))"},
{"lineNum":"  828","line":"      : _M_ptr(__x) { }"},
{"lineNum":"  829","line":""},
{"lineNum":"  830","line":"      _Result"},
{"lineNum":"  831","line":"      operator()(_Arg __x) const"},
{"lineNum":"  832","line":"      { return _M_ptr(__x); }"},
{"lineNum":"  833","line":"    };"},
{"lineNum":"  834","line":""},
{"lineNum":"  835","line":"  /// One of the @link pointer_adaptors adaptors for function pointers@endlink."},
{"lineNum":"  836","line":"  template<typename _Arg, typename _Result>"},
{"lineNum":"  837","line":"    inline pointer_to_unary_function<_Arg, _Result>"},
{"lineNum":"  838","line":"    ptr_fun(_Result (*__x)(_Arg))"},
{"lineNum":"  839","line":"    { return pointer_to_unary_function<_Arg, _Result>(__x); }"},
{"lineNum":"  840","line":""},
{"lineNum":"  841","line":"  /// One of the @link pointer_adaptors adaptors for function pointers@endlink."},
{"lineNum":"  842","line":"  template<typename _Arg1, typename _Arg2, typename _Result>"},
{"lineNum":"  843","line":"    class pointer_to_binary_function"},
{"lineNum":"  844","line":"    : public binary_function<_Arg1, _Arg2, _Result>"},
{"lineNum":"  845","line":"    {"},
{"lineNum":"  846","line":"    protected:"},
{"lineNum":"  847","line":"      _Result (*_M_ptr)(_Arg1, _Arg2);"},
{"lineNum":"  848","line":""},
{"lineNum":"  849","line":"    public:"},
{"lineNum":"  850","line":"      pointer_to_binary_function() { }"},
{"lineNum":"  851","line":""},
{"lineNum":"  852","line":"      explicit"},
{"lineNum":"  853","line":"      pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))"},
{"lineNum":"  854","line":"      : _M_ptr(__x) { }"},
{"lineNum":"  855","line":""},
{"lineNum":"  856","line":"      _Result"},
{"lineNum":"  857","line":"      operator()(_Arg1 __x, _Arg2 __y) const"},
{"lineNum":"  858","line":"      { return _M_ptr(__x, __y); }"},
{"lineNum":"  859","line":"    };"},
{"lineNum":"  860","line":""},
{"lineNum":"  861","line":"  /// One of the @link pointer_adaptors adaptors for function pointers@endlink."},
{"lineNum":"  862","line":"  template<typename _Arg1, typename _Arg2, typename _Result>"},
{"lineNum":"  863","line":"    inline pointer_to_binary_function<_Arg1, _Arg2, _Result>"},
{"lineNum":"  864","line":"    ptr_fun(_Result (*__x)(_Arg1, _Arg2))"},
{"lineNum":"  865","line":"    { return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x); }"},
{"lineNum":"  866","line":"  /** @}  */"},
{"lineNum":"  867","line":""},
{"lineNum":"  868","line":"  template<typename _Tp>"},
{"lineNum":"  869","line":"    struct _Identity"},
{"lineNum":"  870","line":"    : public unary_function<_Tp,_Tp>"},
{"lineNum":"  871","line":"    {"},
{"lineNum":"  872","line":"      _Tp&"},
{"lineNum":"  873","line":"      operator()(_Tp& __x) const"},
{"lineNum":"  874","line":"      { return __x; }"},
{"lineNum":"  875","line":""},
{"lineNum":"  876","line":"      const _Tp&"},
{"lineNum":"  877","line":"      operator()(const _Tp& __x) const"},
{"lineNum":"  878","line":"      { return __x; }"},
{"lineNum":"  879","line":"    };"},
{"lineNum":"  880","line":""},
{"lineNum":"  881","line":"  template<typename _Pair>"},
{"lineNum":"  882","line":"    struct _Select1st"},
{"lineNum":"  883","line":"    : public unary_function<_Pair, typename _Pair::first_type>"},
{"lineNum":"  884","line":"    {"},
{"lineNum":"  885","line":"      typename _Pair::first_type&"},
{"lineNum":"  886","line":"      operator()(_Pair& __x) const"},
{"lineNum":"  887","line":"      { return __x.first; }"},
{"lineNum":"  888","line":""},
{"lineNum":"  889","line":"      const typename _Pair::first_type&"},
{"lineNum":"  890","line":"      operator()(const _Pair& __x) const","class":"lineCov","hits":"1","order":"1046","possible_hits":"1",},
{"lineNum":"  891","line":"      { return __x.first; }","class":"linePartCov","hits":"1","order":"1047","possible_hits":"2",},
{"lineNum":"  892","line":""},
{"lineNum":"  893","line":"#if __cplusplus >= 201103L"},
{"lineNum":"  894","line":"      template<typename _Pair2>"},
{"lineNum":"  895","line":"        typename _Pair2::first_type&"},
{"lineNum":"  896","line":"        operator()(_Pair2& __x) const","class":"lineCov","hits":"1","order":"907","possible_hits":"1",},
{"lineNum":"  897","line":"        { return __x.first; }","class":"linePartCov","hits":"1","order":"908","possible_hits":"2",},
{"lineNum":"  898","line":""},
{"lineNum":"  899","line":"      template<typename _Pair2>"},
{"lineNum":"  900","line":"        const typename _Pair2::first_type&"},
{"lineNum":"  901","line":"        operator()(const _Pair2& __x) const"},
{"lineNum":"  902","line":"        { return __x.first; }"},
{"lineNum":"  903","line":"#endif"},
{"lineNum":"  904","line":"    };"},
{"lineNum":"  905","line":""},
{"lineNum":"  906","line":"  template<typename _Pair>"},
{"lineNum":"  907","line":"    struct _Select2nd"},
{"lineNum":"  908","line":"    : public unary_function<_Pair, typename _Pair::second_type>"},
{"lineNum":"  909","line":"    {"},
{"lineNum":"  910","line":"      typename _Pair::second_type&"},
{"lineNum":"  911","line":"      operator()(_Pair& __x) const"},
{"lineNum":"  912","line":"      { return __x.second; }"},
{"lineNum":"  913","line":""},
{"lineNum":"  914","line":"      const typename _Pair::second_type&"},
{"lineNum":"  915","line":"      operator()(const _Pair& __x) const"},
{"lineNum":"  916","line":"      { return __x.second; }"},
{"lineNum":"  917","line":"    };"},
{"lineNum":"  918","line":""},
{"lineNum":"  919","line":"  // 20.3.8 adaptors pointers members"},
{"lineNum":"  920","line":"  /** @defgroup memory_adaptors Adaptors for pointers to members"},
{"lineNum":"  921","line":"   * @ingroup functors"},
{"lineNum":"  922","line":"   *"},
{"lineNum":"  923","line":"   *  There are a total of 8 = 2^3 function objects in this family."},
{"lineNum":"  924","line":"   *   (1) Member functions taking no arguments vs member functions taking"},
{"lineNum":"  925","line":"   *        one argument."},
{"lineNum":"  926","line":"   *   (2) Call through pointer vs call through reference."},
{"lineNum":"  927","line":"   *   (3) Const vs non-const member function."},
{"lineNum":"  928","line":"   *"},
{"lineNum":"  929","line":"   *  All of this complexity is in the function objects themselves.  You can"},
{"lineNum":"  930","line":"   *   ignore it by using the helper function mem_fun and mem_fun_ref,"},
{"lineNum":"  931","line":"   *   which create whichever type of adaptor is appropriate."},
{"lineNum":"  932","line":"   *"},
{"lineNum":"  933","line":"   *  @{"},
{"lineNum":"  934","line":"   */"},
{"lineNum":"  935","line":"  /// One of the @link memory_adaptors adaptors for member"},
{"lineNum":"  936","line":"  /// pointers@endlink."},
{"lineNum":"  937","line":"  template<typename _Ret, typename _Tp>"},
{"lineNum":"  938","line":"    class mem_fun_t : public unary_function<_Tp*, _Ret>"},
{"lineNum":"  939","line":"    {"},
{"lineNum":"  940","line":"    public:"},
{"lineNum":"  941","line":"      explicit"},
{"lineNum":"  942","line":"      mem_fun_t(_Ret (_Tp::*__pf)())"},
{"lineNum":"  943","line":"      : _M_f(__pf) { }"},
{"lineNum":"  944","line":""},
{"lineNum":"  945","line":"      _Ret"},
{"lineNum":"  946","line":"      operator()(_Tp* __p) const"},
{"lineNum":"  947","line":"      { return (__p->*_M_f)(); }"},
{"lineNum":"  948","line":""},
{"lineNum":"  949","line":"    private:"},
{"lineNum":"  950","line":"      _Ret (_Tp::*_M_f)();"},
{"lineNum":"  951","line":"    };"},
{"lineNum":"  952","line":""},
{"lineNum":"  953","line":"  /// One of the @link memory_adaptors adaptors for member"},
{"lineNum":"  954","line":"  /// pointers@endlink."},
{"lineNum":"  955","line":"  template<typename _Ret, typename _Tp>"},
{"lineNum":"  956","line":"    class const_mem_fun_t : public unary_function<const _Tp*, _Ret>"},
{"lineNum":"  957","line":"    {"},
{"lineNum":"  958","line":"    public:"},
{"lineNum":"  959","line":"      explicit"},
{"lineNum":"  960","line":"      const_mem_fun_t(_Ret (_Tp::*__pf)() const)"},
{"lineNum":"  961","line":"      : _M_f(__pf) { }"},
{"lineNum":"  962","line":""},
{"lineNum":"  963","line":"      _Ret"},
{"lineNum":"  964","line":"      operator()(const _Tp* __p) const"},
{"lineNum":"  965","line":"      { return (__p->*_M_f)(); }"},
{"lineNum":"  966","line":""},
{"lineNum":"  967","line":"    private:"},
{"lineNum":"  968","line":"      _Ret (_Tp::*_M_f)() const;"},
{"lineNum":"  969","line":"    };"},
{"lineNum":"  970","line":""},
{"lineNum":"  971","line":"  /// One of the @link memory_adaptors adaptors for member"},
{"lineNum":"  972","line":"  /// pointers@endlink."},
{"lineNum":"  973","line":"  template<typename _Ret, typename _Tp>"},
{"lineNum":"  974","line":"    class mem_fun_ref_t : public unary_function<_Tp, _Ret>"},
{"lineNum":"  975","line":"    {"},
{"lineNum":"  976","line":"    public:"},
{"lineNum":"  977","line":"      explicit"},
{"lineNum":"  978","line":"      mem_fun_ref_t(_Ret (_Tp::*__pf)())"},
{"lineNum":"  979","line":"      : _M_f(__pf) { }"},
{"lineNum":"  980","line":""},
{"lineNum":"  981","line":"      _Ret"},
{"lineNum":"  982","line":"      operator()(_Tp& __r) const"},
{"lineNum":"  983","line":"      { return (__r.*_M_f)(); }"},
{"lineNum":"  984","line":""},
{"lineNum":"  985","line":"    private:"},
{"lineNum":"  986","line":"      _Ret (_Tp::*_M_f)();"},
{"lineNum":"  987","line":"  };"},
{"lineNum":"  988","line":""},
{"lineNum":"  989","line":"  /// One of the @link memory_adaptors adaptors for member"},
{"lineNum":"  990","line":"  /// pointers@endlink."},
{"lineNum":"  991","line":"  template<typename _Ret, typename _Tp>"},
{"lineNum":"  992","line":"    class const_mem_fun_ref_t : public unary_function<_Tp, _Ret>"},
{"lineNum":"  993","line":"    {"},
{"lineNum":"  994","line":"    public:"},
{"lineNum":"  995","line":"      explicit"},
{"lineNum":"  996","line":"      const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const)"},
{"lineNum":"  997","line":"      : _M_f(__pf) { }"},
{"lineNum":"  998","line":""},
{"lineNum":"  999","line":"      _Ret"},
{"lineNum":" 1000","line":"      operator()(const _Tp& __r) const"},
{"lineNum":" 1001","line":"      { return (__r.*_M_f)(); }"},
{"lineNum":" 1002","line":""},
{"lineNum":" 1003","line":"    private:"},
{"lineNum":" 1004","line":"      _Ret (_Tp::*_M_f)() const;"},
{"lineNum":" 1005","line":"    };"},
{"lineNum":" 1006","line":""},
{"lineNum":" 1007","line":"  /// One of the @link memory_adaptors adaptors for member"},
{"lineNum":" 1008","line":"  /// pointers@endlink."},
{"lineNum":" 1009","line":"  template<typename _Ret, typename _Tp, typename _Arg>"},
{"lineNum":" 1010","line":"    class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>"},
{"lineNum":" 1011","line":"    {"},
{"lineNum":" 1012","line":"    public:"},
{"lineNum":" 1013","line":"      explicit"},
{"lineNum":" 1014","line":"      mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))"},
{"lineNum":" 1015","line":"      : _M_f(__pf) { }"},
{"lineNum":" 1016","line":""},
{"lineNum":" 1017","line":"      _Ret"},
{"lineNum":" 1018","line":"      operator()(_Tp* __p, _Arg __x) const"},
{"lineNum":" 1019","line":"      { return (__p->*_M_f)(__x); }"},
{"lineNum":" 1020","line":""},
{"lineNum":" 1021","line":"    private:"},
{"lineNum":" 1022","line":"      _Ret (_Tp::*_M_f)(_Arg);"},
{"lineNum":" 1023","line":"    };"},
{"lineNum":" 1024","line":""},
{"lineNum":" 1025","line":"  /// One of the @link memory_adaptors adaptors for member"},
{"lineNum":" 1026","line":"  /// pointers@endlink."},
{"lineNum":" 1027","line":"  template<typename _Ret, typename _Tp, typename _Arg>"},
{"lineNum":" 1028","line":"    class const_mem_fun1_t : public binary_function<const _Tp*, _Arg, _Ret>"},
{"lineNum":" 1029","line":"    {"},
{"lineNum":" 1030","line":"    public:"},
{"lineNum":" 1031","line":"      explicit"},
{"lineNum":" 1032","line":"      const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const)"},
{"lineNum":" 1033","line":"      : _M_f(__pf) { }"},
{"lineNum":" 1034","line":""},
{"lineNum":" 1035","line":"      _Ret"},
{"lineNum":" 1036","line":"      operator()(const _Tp* __p, _Arg __x) const"},
{"lineNum":" 1037","line":"      { return (__p->*_M_f)(__x); }"},
{"lineNum":" 1038","line":""},
{"lineNum":" 1039","line":"    private:"},
{"lineNum":" 1040","line":"      _Ret (_Tp::*_M_f)(_Arg) const;"},
{"lineNum":" 1041","line":"    };"},
{"lineNum":" 1042","line":""},
{"lineNum":" 1043","line":"  /// One of the @link memory_adaptors adaptors for member"},
{"lineNum":" 1044","line":"  /// pointers@endlink."},
{"lineNum":" 1045","line":"  template<typename _Ret, typename _Tp, typename _Arg>"},
{"lineNum":" 1046","line":"    class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>"},
{"lineNum":" 1047","line":"    {"},
{"lineNum":" 1048","line":"    public:"},
{"lineNum":" 1049","line":"      explicit"},
{"lineNum":" 1050","line":"      mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))"},
{"lineNum":" 1051","line":"      : _M_f(__pf) { }"},
{"lineNum":" 1052","line":""},
{"lineNum":" 1053","line":"      _Ret"},
{"lineNum":" 1054","line":"      operator()(_Tp& __r, _Arg __x) const"},
{"lineNum":" 1055","line":"      { return (__r.*_M_f)(__x); }"},
{"lineNum":" 1056","line":""},
{"lineNum":" 1057","line":"    private:"},
{"lineNum":" 1058","line":"      _Ret (_Tp::*_M_f)(_Arg);"},
{"lineNum":" 1059","line":"    };"},
{"lineNum":" 1060","line":""},
{"lineNum":" 1061","line":"  /// One of the @link memory_adaptors adaptors for member"},
{"lineNum":" 1062","line":"  /// pointers@endlink."},
{"lineNum":" 1063","line":"  template<typename _Ret, typename _Tp, typename _Arg>"},
{"lineNum":" 1064","line":"    class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>"},
{"lineNum":" 1065","line":"    {"},
{"lineNum":" 1066","line":"    public:"},
{"lineNum":" 1067","line":"      explicit"},
{"lineNum":" 1068","line":"      const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const)"},
{"lineNum":" 1069","line":"      : _M_f(__pf) { }"},
{"lineNum":" 1070","line":""},
{"lineNum":" 1071","line":"      _Ret"},
{"lineNum":" 1072","line":"      operator()(const _Tp& __r, _Arg __x) const"},
{"lineNum":" 1073","line":"      { return (__r.*_M_f)(__x); }"},
{"lineNum":" 1074","line":""},
{"lineNum":" 1075","line":"    private:"},
{"lineNum":" 1076","line":"      _Ret (_Tp::*_M_f)(_Arg) const;"},
{"lineNum":" 1077","line":"    };"},
{"lineNum":" 1078","line":""},
{"lineNum":" 1079","line":"  // Mem_fun adaptor helper functions.  There are only two:"},
{"lineNum":" 1080","line":"  // mem_fun and mem_fun_ref."},
{"lineNum":" 1081","line":"  template<typename _Ret, typename _Tp>"},
{"lineNum":" 1082","line":"    inline mem_fun_t<_Ret, _Tp>"},
{"lineNum":" 1083","line":"    mem_fun(_Ret (_Tp::*__f)())"},
{"lineNum":" 1084","line":"    { return mem_fun_t<_Ret, _Tp>(__f); }"},
{"lineNum":" 1085","line":""},
{"lineNum":" 1086","line":"  template<typename _Ret, typename _Tp>"},
{"lineNum":" 1087","line":"    inline const_mem_fun_t<_Ret, _Tp>"},
{"lineNum":" 1088","line":"    mem_fun(_Ret (_Tp::*__f)() const)"},
{"lineNum":" 1089","line":"    { return const_mem_fun_t<_Ret, _Tp>(__f); }"},
{"lineNum":" 1090","line":""},
{"lineNum":" 1091","line":"  template<typename _Ret, typename _Tp>"},
{"lineNum":" 1092","line":"    inline mem_fun_ref_t<_Ret, _Tp>"},
{"lineNum":" 1093","line":"    mem_fun_ref(_Ret (_Tp::*__f)())"},
{"lineNum":" 1094","line":"    { return mem_fun_ref_t<_Ret, _Tp>(__f); }"},
{"lineNum":" 1095","line":""},
{"lineNum":" 1096","line":"  template<typename _Ret, typename _Tp>"},
{"lineNum":" 1097","line":"    inline const_mem_fun_ref_t<_Ret, _Tp>"},
{"lineNum":" 1098","line":"    mem_fun_ref(_Ret (_Tp::*__f)() const)"},
{"lineNum":" 1099","line":"    { return const_mem_fun_ref_t<_Ret, _Tp>(__f); }"},
{"lineNum":" 1100","line":""},
{"lineNum":" 1101","line":"  template<typename _Ret, typename _Tp, typename _Arg>"},
{"lineNum":" 1102","line":"    inline mem_fun1_t<_Ret, _Tp, _Arg>"},
{"lineNum":" 1103","line":"    mem_fun(_Ret (_Tp::*__f)(_Arg))"},
{"lineNum":" 1104","line":"    { return mem_fun1_t<_Ret, _Tp, _Arg>(__f); }"},
{"lineNum":" 1105","line":""},
{"lineNum":" 1106","line":"  template<typename _Ret, typename _Tp, typename _Arg>"},
{"lineNum":" 1107","line":"    inline const_mem_fun1_t<_Ret, _Tp, _Arg>"},
{"lineNum":" 1108","line":"    mem_fun(_Ret (_Tp::*__f)(_Arg) const)"},
{"lineNum":" 1109","line":"    { return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f); }"},
{"lineNum":" 1110","line":""},
{"lineNum":" 1111","line":"  template<typename _Ret, typename _Tp, typename _Arg>"},
{"lineNum":" 1112","line":"    inline mem_fun1_ref_t<_Ret, _Tp, _Arg>"},
{"lineNum":" 1113","line":"    mem_fun_ref(_Ret (_Tp::*__f)(_Arg))"},
{"lineNum":" 1114","line":"    { return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }"},
{"lineNum":" 1115","line":""},
{"lineNum":" 1116","line":"  template<typename _Ret, typename _Tp, typename _Arg>"},
{"lineNum":" 1117","line":"    inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg>"},
{"lineNum":" 1118","line":"    mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)"},
{"lineNum":" 1119","line":"    { return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }"},
{"lineNum":" 1120","line":""},
{"lineNum":" 1121","line":"  /** @}  */"},
{"lineNum":" 1122","line":""},
{"lineNum":" 1123","line":"_GLIBCXX_END_NAMESPACE_VERSION"},
{"lineNum":" 1124","line":"} // namespace"},
{"lineNum":" 1125","line":""},
{"lineNum":" 1126","line":"#if (__cplusplus < 201103L) || _GLIBCXX_USE_DEPRECATED"},
{"lineNum":" 1127","line":"# include <backward/binders.h>"},
{"lineNum":" 1128","line":"#endif"},
{"lineNum":" 1129","line":""},
{"lineNum":" 1130","line":"#endif /* _STL_FUNCTION_H */"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "mipl_parser", "date" : "2018-11-28 14:11:04", "instrumented" : 6, "covered" : 6,};
var merged_data = [];
